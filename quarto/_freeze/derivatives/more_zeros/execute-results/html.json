{
  "hash": "8c204c3f57d4e82d881355a3cbfe59e0",
  "result": {
    "markdown": "# Derivative-free alternatives to Newton's method\n\n\n\nThis section uses these add-on packages:\n\n``` {.julia .cell-code}\nusing CalculusWithJulia\nusing Plots\nusing ImplicitEquations\nusing Roots\nusing SymPy\n```\n\n\n\n\n---\n\n\nNewton's method is not the only algorithm of its kind for identifying zeros of a function. In this section we discuss some alternatives.\n\n\n## The `find_zero(f, x0)` function\n\n\nThe  function `find_zero` from the `Roots` packages provides several different algorithms for finding a zero of a function, including some a derivative-free algorithms for finding zeros  when started with an initial guess. The default method is similar to Newton's method in that only a good initial guess is needed. However, the algorithm, while possibly slower in terms of function evaluations and steps,  is engineered to be a bit more robust to the choice of initial estimate than Newton's method. (If it finds a bracket, it will use a bisection algorithm which is guaranteed to converge, but can be slower to do so.) Here we see how to call the function:\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nf(x) = cos(x) - x\nx₀ = 1\nfind_zero(f, x₀)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n0.7390851332151607\n```\n:::\n:::\n\n\nCompare to this related call which uses the bisection method:\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\nfind_zero(f, (0, 1))           ## [0,1] must be a bracketing interval\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n0.7390851332151607\n```\n:::\n:::\n\n\nFor this example both give the same answer, but the bisection method is a bit less convenient as a bracketing interval must be pre-specified.\n\n\n## The secant method\n\n\nThe default `find_zero` method above uses a secant-like method unless a bracketing method is found.  The secant method is historic, dating back over $3000$ years. Here we discuss the secant method in a more general framework.\n\n\nOne way to view Newton's method is through the inverse of $f$ (assuming it exists): if $f(\\alpha) = 0$ then $\\alpha = f^{-1}(0)$.\n\n\nIf $f$ has a simple zero at $\\alpha$ and is locally invertible (that is some $f^{-1}$ exists) then the update step for Newton's method can be identified with:\n\n\n  * fitting a polynomial to the local inverse function of $f$ going through through the point $(f(x_0),x_0)$,\n  * and matching the slope of $f$ at the same point.\n\n\nThat is, we can write $g(y) = h_0 + h_1 (y-f(x_0))$. Then $g(f(x_0)) = x_0 = h_0$, so $h_0 = x_0$. From $g'(f(x_0)) = 1/f'(x_0)$, we get $h_1 = 1/f'(x_0)$. That is, $g(y) = x_0 + (y-f(x_0))/f'(x_0)$. At $y=0,$ we get the update step $x_1 = g(0) = x_0 - f(x_0)/f'(x_0)$.\n\n\nA similar viewpoint can be used  to create derivative-free methods.\n\n\nFor example, the  [secant method](https://en.wikipedia.org/wiki/Secant_method) can be seen as the result of fitting a degree-$1$ polynomial approximation for  $f^{-1}$ through two points $(f(x_0),x_0)$ and $(f(x_1), x_1)$.\n\n\nAgain, expressing this approximation as $g(y) = h_0 + h_1(y-f(x_1))$ leads to $g(f(x_1)) = x_1 = h_0$. Substituting $f(x_0)$ gives $g(f(x_0)) = x_0 = x_1 + h_1(f(x_0)-f(x_1))$.  Solving for $h_1$ leads to $h_1=(x_1-x_0)/(f(x_1)-f(x_0))$. Then $x_2 = g(0) = x_1 + (x_1-x_0)/(f(x_1)-f(x_0)) \\cdot f(x_1)$. This is the first step of the secant method:\n\n\n\n$$\nx_{n+1} = x_n - f(x_n) \\frac{x_n - x_{n-1}}{f(x_n) - f(x_{n-1})}.\n$$\n\n\nThat is, where the next step of  Newton's method comes from the intersection of the tangent line at $x_n$ with the $x$-axis, the next step of the secant method comes from the intersection of the secant line defined by $x_n$ and $x_{n-1}$ with the $x$ axis. That is, the secant method simply replaces $f'(x_n)$ with the slope of the secant line between $x_n$ and $x_{n-1}$.\n\n\nWe code the update step as `λ2`:\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\nλ2(f0,f1,x0,x1) = x1 - f1 * (x1-x0) / (f1-f0)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nλ2 (generic function with 1 method)\n```\n:::\n:::\n\n\nThen we can run a few steps to identify the zero of sine starting at $3$ and $4$\n\n::: {.cell hold='true' term='true' execution_count=7}\n``` {.julia .cell-code}\nx0,x1 = 4,3\nf0,f1 = sin.((x0,x1))\n@show x1,f1\n\nx0,x1 = x1, λ2(f0,f1,x0,x1)\nf0,f1 = f1, sin(x1)\n@show x1,f1\n\nx0,x1 = x1, λ2(f0,f1,x0,x1)\nf0,f1 = f1, sin(x1)\n@show x1,f1\n\nx0,x1 = x1, λ2(f0,f1,x0,x1)\nf0,f1 = f1, sin(x1)\n@show x1,f1\n\nx0,x1 = x1, λ2(f0,f1,x0,x1)\nf0,f1 = f1, sin(x1)\nx1,f1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(x1, f1) = (3, 0.1411200080598672)\n(x1, f1) = (3.157162792479947, -0.015569509788328599)\n(x1, f1) = (3.14154625558915, 4.639800062679684e-5)\n(x1, f1) = (3.1415926554589646, -1.8691713617942337e-9)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n(3.141592653589793, 1.2246467991473532e-16)\n```\n:::\n:::\n\n\nLike Newton's method, the secant method coverges quickly for this problem (though its rate is less than the quadratic rate of Newton's method).\n\n\nThis method is included in `Roots` as `Secant()` (or `Order1()`):\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\nfind_zero(sin, (4,3), Secant())\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n3.141592653589793\n```\n:::\n:::\n\n\nThough the derivative is related to the slope of the secant line, that is in the limit. The convergence of the secant method is not as fast as Newton's method, though at each step of the secant method, only one new function evaluation is needed, so it can be more efficient for functions that are expensive to compute or differentiate.\n\n\nLet $\\epsilon_{n+1} = x_{n+1}-\\alpha$, where $\\alpha$ is assumed to be the *simple* zero of $f(x)$ that the secant method converges to. A [calculation](https://math.okstate.edu/people/binegar/4513-F98/4513-l08.pdf) shows that\n\n\n\n$$\n\\begin{align*}\n\\epsilon_{n+1} &\\approx \\frac{x_n-x_{n-1}}{f(x_n)-f(x_{n-1})} \\frac{(1/2)f''(\\alpha)(e_n-e_{n-1})}{x_n-x_{n-1}} \\epsilon_n \\epsilon_{n-1}\\\\\n& \\approx \\frac{f''(\\alpha)}{2f'(\\alpha)} \\epsilon_n \\epsilon_{n-1}\\\\\n&= C  \\epsilon_n \\epsilon_{n-1}.\n\\end{align*}\n$$\n\n\nThe constant `C` is similar to that for Newton's method, and reveals potential troubles for the secant method similar to those of Newton's method: a poor initial guess (the initial error is too big), the second derivative is too large, the first derivative too flat near the answer.\n\n\nAssuming the error term has the form $\\epsilon_{n+1} = A|\\epsilon_n|^\\phi$ and substituting into the above leads to the equation\n\n\n\n$$\n\\frac{A^{1-1/\\phi}}{C} = |\\epsilon_n|^{1 - \\phi +1/\\phi}.\n$$\n\n\nThe left side being a constant suggests $\\phi$ solves: $1 - \\phi + 1/\\phi = 0$ or $\\phi^2 -\\phi - 1 = 0$. The solution is the golden ratio, $(1 + \\sqrt{5})/2 \\approx 1.618\\dots$.\n\n\n### Steffensen's method\n\n\nSteffensen's method is a secant-like method that converges with $|\\epsilon_{n+1}| \\approx C |\\epsilon_n|^2$. The secant is taken between the points $(x_n,f(x_n))$ and  $(x_n + f(x_n), f(x_n + f(x_n))$. Like Newton's method this requires $2$ function evaluations per step. Steffensen's is implemented through `Roots.Steffensen()`. Steffensen's method is more sensitive to the initial guess than other methods, so in practice must be used with care, though it is a starting point for many higher-order derivative-free methods.\n\n\n## Inverse quadratic interpolation\n\n\nInverse quadratic interpolation fits a quadratic polynomial through three points, not just two like the Secant method. The third being $(f(x_2), x_2)$.\n\n\nFor example, here is the inverse quadratic function, $g(y)$, going through three points marked with red dots. The blue dot is found from $(g(0), 0)$.\n\n::: {.cell hold='true' execution_count=9}\n\n::: {.cell-output .cell-output-display execution_count=10}\n![](more_zeros_files/figure-html/cell-10-output-1.svg){}\n:::\n:::\n\n\nHere we use `SymPy` to identify the degree-$2$ polynomial as a function of $y$, then evaluate it at $y=0$ to find the next step:\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\n@syms y hs[0:2] xs[0:2] fs[0:2]\nH(y) = sum(hᵢ*(y - fs[end])^i for (hᵢ,i) ∈ zip(hs, 0:2))\n\neqs = [H(fᵢ) ~ xᵢ for (xᵢ, fᵢ) ∈ zip(xs, fs)]\nϕ = solve(eqs, hs)\nhy = subs(H(y), ϕ)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```{=html}\n<span class=\"math-left-align\" style=\"padding-left: 4px; width:0; float:left;\"> \n\\[\nxs₂ + \\frac{\\left(- fs₂ + y\\right)^{2} \\left(- fs₀ xs₁ + fs₀ xs₂ + fs₁ xs₀ - fs₁ xs₂ - fs₂ xs₀ + fs₂ xs₁\\right)}{fs₀^{2} fs₁ - fs₀^{2} fs₂ - fs₀ fs₁^{2} + fs₀ fs₂^{2} + fs₁^{2} fs₂ - fs₁ fs₂^{2}} + \\frac{\\left(- fs₂ + y\\right) \\left(fs₀^{2} xs₁ - fs₀^{2} xs₂ - 2 fs₀ fs₂ xs₁ + 2 fs₀ fs₂ xs₂ - fs₁^{2} xs₀ + fs₁^{2} xs₂ + 2 fs₁ fs₂ xs₀ - 2 fs₁ fs₂ xs₂ - fs₂^{2} xs₀ + fs₂^{2} xs₁\\right)}{fs₀^{2} fs₁ - fs₀^{2} fs₂ - fs₀ fs₁^{2} + fs₀ fs₂^{2} + fs₁^{2} fs₂ - fs₁ fs₂^{2}}\n\\]\n</span>\n```\n:::\n:::\n\n\nThe value of `hy` at $y=0$ yields the next guess based on the past three, and is given by:\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\nq⁻¹ = hy(y => 0)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```{=html}\n<span class=\"math-left-align\" style=\"padding-left: 4px; width:0; float:left;\"> \n\\[\n\\frac{fs₂^{2} \\left(- fs₀ xs₁ + fs₀ xs₂ + fs₁ xs₀ - fs₁ xs₂ - fs₂ xs₀ + fs₂ xs₁\\right)}{fs₀^{2} fs₁ - fs₀^{2} fs₂ - fs₀ fs₁^{2} + fs₀ fs₂^{2} + fs₁^{2} fs₂ - fs₁ fs₂^{2}} - \\frac{fs₂ \\left(fs₀^{2} xs₁ - fs₀^{2} xs₂ - 2 fs₀ fs₂ xs₁ + 2 fs₀ fs₂ xs₂ - fs₁^{2} xs₀ + fs₁^{2} xs₂ + 2 fs₁ fs₂ xs₀ - 2 fs₁ fs₂ xs₂ - fs₂^{2} xs₀ + fs₂^{2} xs₁\\right)}{fs₀^{2} fs₁ - fs₀^{2} fs₂ - fs₀ fs₁^{2} + fs₀ fs₂^{2} + fs₁^{2} fs₂ - fs₁ fs₂^{2}} + xs₂\n\\]\n</span>\n```\n:::\n:::\n\n\nThough the above can be simplified quite a bit when computed by hand, here we simply make this a function with `lambdify` which we will use below.\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code}\nλ3 = lambdify(q⁻¹) # fs, then xs\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n#118 (generic function with 1 method)\n```\n:::\n:::\n\n\n(`SymPy`'s `lambdify` function, by default, picks the order of its argument lexicographically, in this case they will be the `f` values then the `x` values.)\n\n\nAn inverse quadratic step is utilized by Brent's method, as possible, to yield a rapidly convergent bracketing algorithm implemented as a default zero finder in many software languages.  `Julia`'s `Roots` package implements the method in `Roots.Brent()`. An inverse cubic interpolation is utilized by [Alefeld, Potra, and Shi](https://dl.acm.org/doi/10.1145/210089.210111) which gives an asymptotically even more rapidly convergent algorithm then Brent's (implemented in `Roots.AlefeldPotraShi()` and also `Roots.A42()`). This is used as a finishing step in many cases by the default hybrid `Order0()` method of `find_zero`.\n\n\nIn a bracketing algorithm, the next step should reduce the size of the bracket, so the next iterate should be inside the current bracket. However, quadratic convergence does not guarantee this to happen. As such, sometimes a subsitute method must be chosen.\n\n\n[Chandrapatla's](https://www.google.com/books/edition/Computational_Physics/cC-8BAAAQBAJ?hl=en&gbpv=1&pg=PA95&printsec=frontcover) method, is a bracketing method utilizing an inverse quadratic step as the centerpiece. The key insight is the test to choose between this inverse quadratic step and a bisection step. This is done in the following based on values of $\\xi$ and $\\Phi$ defined within:\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\nfunction chandrapatla(f, u, v, λ; verbose=false)\n    a,b = promote(float(u), float(v))\n    fa,fb = f(a),f(b)\n    @assert fa * fb < 0\n\n    if abs(fa) < abs(fb)\n        a,b,fa,fb = b,a,fb,fa\n    end\n\n    c, fc = a, fa\n\n    maxsteps = 100\n    for ns in 1:maxsteps\n\n        Δ = abs(b-a)\n        m, fm = (abs(fa) < abs(fb)) ? (a, fa) : (b, fb)\n        ϵ = eps(m)\n        if Δ ≤ 2ϵ\n          return m\n        end\n        @show m,fm\n        iszero(fm) && return m\n\n        ξ = (a-b)/(c-b)\n        Φ = (fa-fb)/(fc-fb)\n\n        if Φ^2 < ξ < 1 - (1-Φ)^2\n            xt = λ(fa,fc,fb, a,c,b) # inverse quadratic\n        else\n            xt = a + (b-a)/2\n        end\n\n        ft = f(xt)\n\n        isnan(ft) && break\n\n        if sign(fa) == sign(ft)\n            c,fc = a,fa\n            a,fa = xt,ft\n        else\n            c,b,a = b,a,xt\n            fc,fb,fa = fb,fa,ft\n        end\n\n    \tverbose && @show ns, a, fa\n\n    end\n    error(\"no convergence: [a,b] = $(sort([a,b]))\")\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\nchandrapatla (generic function with 1 method)\n```\n:::\n:::\n\n\nLike bisection, this method ensures that $a$ and $b$ is a bracket, but it moves $a$ to the newest estimate, so does not maintain that $a < b$ throughout.\n\n\nWe can see it in action on the sine function.   Here we pass in $\\lambda$, but in a real implementation (as in `Roots.Chandrapatla()`) we would have programmed the algorithm to compute the inverse quadratic value.\n\n::: {.cell term='true' execution_count=14}\n``` {.julia .cell-code}\nchandrapatla(sin, 3, 4,  λ3, verbose=true)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(m, fm) = (3.0, 0.1411200080598672)\n(ns, a, fa) = (1, 3.5, -0.35078322768961984)\n(m, fm) = (3.0, 0.1411200080598672)\n(ns, a, fa) = \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n(2, 3.1315894157911264, 0.010003070970892524)\n(m, fm) = (3.1315894157911264, 0.010003070970892524)\n(ns, a, fa) = (3, 3.141678836157296, -8.618256739611538e-5)\n(m, fm) = (3.141678836157296, -8.618256739611538e-5)\n(ns, a, fa) = (4, 3.141592600257386, 5.3332407057633926e-8)\n(m, fm) = (3.141592600257386, 5.3332407057633926e-8)\n(ns, a, fa) = (5, 3.1415926535898007, -7.42705188753633e-15)\n(m, fm) = (3.1415926535898007, -7.42705188753633e-15)\n(ns, a, fa) = (6, 3.141592653589793, 1.2246467991473532e-16)\n(m, fm) = (3.141592653589793, 1.2246467991473532e-16)\n(ns, a, fa) = (7, 3.1415926535897936, -3.216245299353273e-16)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n3.141592653589793\n```\n:::\n:::\n\n\nThe condition `Φ^2 < ξ < 1 - (1-Φ)^2` can be visualized. Assume `a,b=0,1`, `fa,fb=-1/2,1`, Then `c < a < b`, and `fc` has the same sign as `fa`, but what values of `fc` will satisfy the inequality?\n\n::: {.cell execution_count=15}\n``` {.julia .cell-code}\nξ(c,fc) = (a-b)/(c-b)\nΦ(c,fc) = (fa-fb)/(fc-fb)\nΦl(c,fc) = Φ(c,fc)^2\nΦr(c,fc) = 1 - (1-Φ(c,fc))^2\na,b = 0, 1\nfa,fb = -1/2, 1\nregion = Lt(Φl, ξ) & Lt(ξ,Φr)\nplot(region, xlims=(-2,a), ylims=(-3,0))\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n![](more_zeros_files/figure-html/cell-16-output-1.svg){}\n:::\n:::\n\n\nWhen `(c,fc)` is in the shaded area, the inverse quadratic step is chosen. We can see that `fc < fa` is needed.\n\n\nFor these values, this area is within the area where a implicit quadratic step will result in a value between `a` and `b`:\n\n::: {.cell execution_count=16}\n``` {.julia .cell-code}\nl(c,fc) = λ3(fa,fb,fc,a,b,c)\nregion₃ = ImplicitEquations.Lt(l,b) & ImplicitEquations.Gt(l,a)\nplot(region₃, xlims=(-2,0), ylims=(-3,0))\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n![](more_zeros_files/figure-html/cell-17-output-1.svg){}\n:::\n:::\n\n\nThere are values in the parameter space where this does not occur.\n\n\n## Tolerances\n\n\nThe `chandrapatla` algorithm typically waits until `abs(b-a) <= 2eps(m)` (where $m$ is either $b$ or $a$ depending on the size of $f(a)$ and $f(b)$) is satisfied. Informally this means the algorithm stops when the two bracketing values are no more than a small amount apart. What is a \"small amount?\"\n\n\nTo understand, we start with the fact that floating point numbers are an approximation to real numbers.\n\n\nFloating point numbers effectively represent a number in scientific notation in terms of\n\n\n  * a sign (plus or minus) ,\n  * a *mantissa* (a number in $[1,2)$, in binary ), and\n  * an exponent (to represent a power of $2$).\n\n\nThe mantissa is of the form `1.xxxxx...xxx` where there are $m$ different `x`s each possibly a `0` or `1`. The `i`th `x` indicates if the term `1/2^i` should be included in the value.  The mantissa is the sum of `1` plus the indicated values of `1/2^i` for `i` in `1` to `m`. So the last `x` represents if `1/2^m` should be included in the sum. As such, the mantissa represents a discrete set of values, separated by `1/2^m`, as that is the smallest difference possible.\n\n\nFor example if `m=2` then the possible value for the mantissa are `11 => 1 + 1/2 + 1/4 = 7/4`, `10 => 1 + 1/2 = 6/4`, `01 => 1 + 1/4 = 5/4`. and `00 => 1 = 4/4`, values separated by `1/4 = 1/2^m`.\n\n\nFor $64$-bit floating point numbers `m=52`, so the values in the mantissa differ by `1/2^52 = 2.220446049250313e-16`. This is the value of `eps()`.\n\n\nHowever, this \"gap\" between numbers is for values when the exponent is `0`. That is the numbers in `[1,2)`. For values in `[2,4)` the gap is twice, between `[1/2,1)` the gap is half. That is the gap depends on the size of the number. The gap between `x` and its next largest floating point number  is given by `eps(x)` and that always satisfies `eps(x) <= eps() * abs(x)`.\n\n\nOne way to think about this is the difference between `x` and the next largest floating point values is *basically* `x*(1+eps()) - x` or `x*eps()`.\n\n\nFor the specific example, `abs(b-a) <= 2eps(m)`  means that the gap between `a` and `b` is essentially 2 floating point values from the $x$ value with the smallest $f(x)$ value.\n\n\nFor bracketing methods that is about as good as you can get. However, once floating values are understood, the absolute best you can get for a bracketing interval would be\n\n\n  * along the way, a value `f(c)` is found which is *exactly* `0.0`\n  * the endpoints of the bracketing interval are *adjacent* floating point values, meaning the interval can not be bisected and `f` changes sign between the two values.\n\n\nThere can be problems when the stopping criteria is `abs(b-a) <= 2eps(m))` and the answer is `0.0` that require engineering around. For example, the algorithm above for the function `f(x) =  -40*x*exp(-x)` does not converge when started with `[-9,1]`, even though `0.0` is an obvious zero.\n\n::: {.cell hold='true' execution_count=17}\n``` {.julia .cell-code}\nfu(x) = -40*x*exp(-x)\nchandrapatla(fu, -9, 1, λ3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(m, fm) = (1.0, -14.715177646857693)\n(m, fm) = (1.0, -14.715177646857693)\n(m, fm) = (1.0, -14.715177646857693)\n(m, fm) = (-0.25, 12.840254166877415)\n(m, fm) = (0.375, -10.309339181864583)\n(m, fm) = (0.0625, -2.3485326570336893)\n(m, fm) = (-0.010153633209987412, 0.41029018616686774)\n(m, fm) = (0.00020479607707152292, -0.008190165597310655)\n(m, fm) = (-2.0313182169488797e-7, 8.125274518297165e-6)\n(m, fm) = (6.287189464795201e-13, -2.5148757859164994e-11)\n(m, fm) = (-5.293955920339377e-23, 2.117582368135751e-21)\n(m, fm) = (1.0097419586828951e-28, -4.0389678347315804e-27)\n(m, fm) = (-5.877471754111438e-39, 2.350988701644575e-37)\n(m, fm) = (1.1210387714598537e-44, -4.484155085839415e-43)\n(m, fm) = (-6.525304467998525e-55, 2.61012178719941e-53)\n(m, fm) = (1.2446030555722283e-60, -4.978412222288913e-59)\n(m, fm) = (-7.24454326306137e-71, 2.897817305224548e-69)\n(m, fm) = (1.3817869688151111e-76, -5.527147875260445e-75)\n(m, fm) = (-8.043058733543795e-87, 3.217223493417518e-85)\n(m, fm) = (1.5340917079055395e-92, -6.136366831622158e-91)\n(m, fm) = (-8.929588994392773e-103, 3.5718355977571093e-101)\n(m, fm) = (1.7031839360032603e-108, -6.812735744013041e-107)\n(m, fm) = (-9.913835302014255e-119, 3.965534120805702e-117)\n(m, fm) = (1.8909140209225187e-124, -7.563656083690075e-123)\n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nLoadError: no convergence: [a,b] = [-9.913835302014255e-119, 1.8909140209225187e-124]\n```\n:::\n:::\n\n\nHere the issue is `abs(b-a)` is tiny (of the order `1e-119`) but `eps(m)` is even smaller.\n\n\nFor non-bracketing methods, like Newton's method or the secant method, different criteria are useful. There may not be a bracketing interval for `f` (for example `f(x) = (x-1)^2`) so the second criteria above might need to be restated in terms of the last two iterates, $x_n$ and $x_{n-1}$. Calling this difference $\\Delta = |x_n - x_{n-1}|$, we might stop if $\\Delta$ is small enough. As there are scenarios where this can happen, but the function is not at a zero, a check on the size of $f$ is needed.\n\n\nHowever, there may be no floating point value where $f$ is exactly `0.0` so checking the size of `f(x_n)` requires some agreement.\n\n\nFirst if `f(x_n)` is `0.0` then it makes sense to call `x_n` an *exact zero* of $f$, even though this may hold even if `x_n`, a floating point value, is not mathematically an *exact* zero of $f$. (Consider `f(x) = x^2 - 2x + 1`. Mathematically, this is identical to `g(x) = (x-1)^2`, but `f(1 + eps())` is zero, while `g(1+eps())` is `4.930380657631324e-32`.\n\n\nHowever, there may never be a value with `f(x_n)` exactly `0.0`. (The value of `sin(pi)` is not zero, for example, as `pi` is an approximation to $\\pi$, as well the `sin` of values adjacent to `float(pi)` do not produce `0.0` exactly.)\n\n\nSuppose `x_n` is the closest floating number to $\\alpha$, the zero. Then the relative rounding error, $($ `x_n` $- \\alpha)/\\alpha$, will be a value $(1 + \\delta)$ with $\\delta$ less than `eps()`.\n\n\nHow far then can `f(x_n)` be from $0 = f(\\alpha)$?\n\n\n\n$$\nf(x_n) = f(x_n - \\alpha + \\alpha) =  f(\\alpha + \\alpha \\cdot \\delta) = f(\\alpha \\cdot (1 + \\delta)),\n$$\n\n\nAssuming $f$ has a derivative, the linear approximation gives:\n\n\n\n$$\nf(x_n) \\approx f(\\alpha) + f'(\\alpha) \\cdot (\\alpha\\delta) = f'(\\alpha) \\cdot \\alpha \\delta\n$$\n\n\nSo we should consider `f(x_n)` an *approximate zero* when it is on the scale of $f'(\\alpha) \\cdot \\alpha \\delta$.\n\n\nThat $\\alpha$ factor means we consider a *relative* tolerance for `f`. Also important – when `x_n` is close to  `0`, is the need for an *absolute* tolerance, one not dependent on the size of `x`. So a good condition to check if `f(x_n)` is small is\n\n\n`abs(f(x_n)) <= abs(x_n) * rtol + atol`, or `abs(f(x_n)) <= max(abs(x_n) * rtol, atol)`\n\n\nwhere the relative tolerance, `rtol`, would absorb an estimate for $f'(\\alpha)$.\n\n\nNow, in Newton's method the update step is $f(x_n)/f'(x_n)$. Naturally when $f(x_n)$ is close to $0$, the update step is small and $\\Delta$ will be close to $0$. *However*, should $f'(x_n)$ be large, then $\\Delta$ can also be small and the algorithm will possibly stop, as $x_{n+1} \\approx x_n$ – but not necessarily $x_{n+1} \\approx \\alpha$. So termination on $\\Delta$ alone can be off. Checking if $f(x_{n+1})$ is an approximate zero is  also useful to include in a stopping criteria.\n\n\nOne thing to keep in mind is that the right-hand side of the rule `abs(f(x_n)) <= abs(x_n) * rtol + atol`, as a function of `x_n`, goes to `Inf` as `x_n` increases. So if `f` has `0` as an asymptote (like `e^(-x)`) for large enough `x_n`, the rule will be `true` and `x_n` could be counted as an approximate zero, despite it not being one.\n\n\nSo a modified criteria for convergence might look like:\n\n\n  * stop if $\\Delta$ is small and `f` is an approximate zero with some tolerances\n  * stop if `f` is an approximate zero with some tolerances, but be mindful that this rule can identify mathematically erroneous answers.\n\n\nIt is not uncommon to assign `rtol` to have a value like `sqrt(eps())` to account for accumulated floating point errors and the factor of $f'(\\alpha)$, though in the `Roots` package it is set smaller by default.\n\n\n## Questions\n\n\n###### Question\n\n\nLet `f(x) = tanh(x)` (the hyperbolic tangent) and `fp(x) = sech(x)^2`, its derivative.\n\n\nDoes *Newton's* method (using `Roots.Newton()`) converge starting at `1.0`?\n\n::: {.cell hold='true' execution_count=18}\n\n::: {.cell-output .cell-output-display execution_count=19}\n```{=html}\n<form class=\"mx-2 my-3 mw-100\" name='WeaveQuestion' data-id='13567660816150847575' data-controltype=''>\n  <div class='form-group '>\n    <div class='controls'>\n      <div class=\"form\" id=\"controls_13567660816150847575\">\n        <div style=\"padding-top: 5px\">\n    <div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_13567660816150847575_1\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_13567660816150847575\"\n              id=\"radio_13567660816150847575_1\" value=\"1\">\n      </input>\n      <span class=\"label-body px-1\">\n        Yes\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_13567660816150847575_2\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_13567660816150847575\"\n              id=\"radio_13567660816150847575_2\" value=\"2\">\n      </input>\n      <span class=\"label-body px-1\">\n        No\n      </span>\n    </label>\n</div>\n\n    \n        </div>\n      </div>\n      <div id='13567660816150847575_message' style=\"padding-bottom: 15px\"></div>\n    </div>\n  </div>\n</form>\n\n<script text='text/javascript'>\ndocument.querySelectorAll('input[name=\"radio_13567660816150847575\"]').forEach(function(rb) {\nrb.addEventListener(\"change\", function() {\n    var correct = rb.value == 1;\n    var msgBox = document.getElementById('13567660816150847575_message');\n      if(correct) {\n    msgBox.innerHTML = \"<div class='pluto-output admonition note alert alert-success'><span> 👍&nbsp; Correct </span></div>\";\n    var explanation = document.getElementById(\"explanation_13567660816150847575\")\n    if (explanation != null) {\n       explanation.style.display = \"none\";\n    }\n  } else {\n    msgBox.innerHTML = \"<div class='pluto-output admonition alert alert-danger'><span>👎&nbsp; Incorrect </span></div>\";\n    var explanation = document.getElementById(\"explanation_13567660816150847575\")\n    if (explanation != null) {\n       explanation.style.display = \"block\";\n    }\n  }\n\n})});\n\n</script>\n```\n:::\n:::\n\n\nDoes *Newton's* method (using `Roots.Newton()`) converge starting at `1.3`?\n\n::: {.cell hold='true' execution_count=19}\n\n::: {.cell-output .cell-output-display execution_count=20}\n```{=html}\n<form class=\"mx-2 my-3 mw-100\" name='WeaveQuestion' data-id='8180473384121923348' data-controltype=''>\n  <div class='form-group '>\n    <div class='controls'>\n      <div class=\"form\" id=\"controls_8180473384121923348\">\n        <div style=\"padding-top: 5px\">\n    <div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_8180473384121923348_1\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_8180473384121923348\"\n              id=\"radio_8180473384121923348_1\" value=\"1\">\n      </input>\n      <span class=\"label-body px-1\">\n        Yes\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_8180473384121923348_2\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_8180473384121923348\"\n              id=\"radio_8180473384121923348_2\" value=\"2\">\n      </input>\n      <span class=\"label-body px-1\">\n        No\n      </span>\n    </label>\n</div>\n\n    \n        </div>\n      </div>\n      <div id='8180473384121923348_message' style=\"padding-bottom: 15px\"></div>\n    </div>\n  </div>\n</form>\n\n<script text='text/javascript'>\ndocument.querySelectorAll('input[name=\"radio_8180473384121923348\"]').forEach(function(rb) {\nrb.addEventListener(\"change\", function() {\n    var correct = rb.value == 2;\n    var msgBox = document.getElementById('8180473384121923348_message');\n      if(correct) {\n    msgBox.innerHTML = \"<div class='pluto-output admonition note alert alert-success'><span> 👍&nbsp; Correct </span></div>\";\n    var explanation = document.getElementById(\"explanation_8180473384121923348\")\n    if (explanation != null) {\n       explanation.style.display = \"none\";\n    }\n  } else {\n    msgBox.innerHTML = \"<div class='pluto-output admonition alert alert-danger'><span>👎&nbsp; Incorrect </span></div>\";\n    var explanation = document.getElementById(\"explanation_8180473384121923348\")\n    if (explanation != null) {\n       explanation.style.display = \"block\";\n    }\n  }\n\n})});\n\n</script>\n```\n:::\n:::\n\n\nDoes the secant method (using `Roots.Secant()`) converge starting at `1.3`? (a second starting value will automatically be chosen, if not directly passed in.)\n\n::: {.cell hold='true' execution_count=20}\n\n::: {.cell-output .cell-output-display execution_count=21}\n```{=html}\n<form class=\"mx-2 my-3 mw-100\" name='WeaveQuestion' data-id='13344185813007989766' data-controltype=''>\n  <div class='form-group '>\n    <div class='controls'>\n      <div class=\"form\" id=\"controls_13344185813007989766\">\n        <div style=\"padding-top: 5px\">\n    <div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_13344185813007989766_1\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_13344185813007989766\"\n              id=\"radio_13344185813007989766_1\" value=\"1\">\n      </input>\n      <span class=\"label-body px-1\">\n        Yes\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_13344185813007989766_2\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_13344185813007989766\"\n              id=\"radio_13344185813007989766_2\" value=\"2\">\n      </input>\n      <span class=\"label-body px-1\">\n        No\n      </span>\n    </label>\n</div>\n\n    \n        </div>\n      </div>\n      <div id='13344185813007989766_message' style=\"padding-bottom: 15px\"></div>\n    </div>\n  </div>\n</form>\n\n<script text='text/javascript'>\ndocument.querySelectorAll('input[name=\"radio_13344185813007989766\"]').forEach(function(rb) {\nrb.addEventListener(\"change\", function() {\n    var correct = rb.value == 1;\n    var msgBox = document.getElementById('13344185813007989766_message');\n      if(correct) {\n    msgBox.innerHTML = \"<div class='pluto-output admonition note alert alert-success'><span> 👍&nbsp; Correct </span></div>\";\n    var explanation = document.getElementById(\"explanation_13344185813007989766\")\n    if (explanation != null) {\n       explanation.style.display = \"none\";\n    }\n  } else {\n    msgBox.innerHTML = \"<div class='pluto-output admonition alert alert-danger'><span>👎&nbsp; Incorrect </span></div>\";\n    var explanation = document.getElementById(\"explanation_13344185813007989766\")\n    if (explanation != null) {\n       explanation.style.display = \"block\";\n    }\n  }\n\n})});\n\n</script>\n```\n:::\n:::\n\n\n###### Question\n\n\nFor the function `f(x) = x^5 - x - 1` both Newton's method and the secant method will converge to the one root when started from `1.0`. Using `verbose=true` as an argument to `find_zero`, (e.g., `find_zero(f, x0, Roots.Secant(), verbose=true)`) how many *more* steps does the secant method need to converge?\n\n::: {.cell hold='true' execution_count=21}\n\n::: {.cell-output .cell-output-display execution_count=22}\n```{=html}\n<form class=\"mx-2 my-3 mw-100\" name='WeaveQuestion' data-id='8306994115733070077' data-controltype=''>\n  <div class='form-group '>\n    <div class='controls'>\n      <div class=\"form\" id=\"controls_8306994115733070077\">\n        <div style=\"padding-top: 5px\">\n    </br>\n<div class=\"input-group\">\n    <input id=\"8306994115733070077\" type=\"number\" class=\"form-control\" placeholder=\"Numeric answer\">\n</div>\n\n    \n        </div>\n      </div>\n      <div id='8306994115733070077_message' style=\"padding-bottom: 15px\"></div>\n    </div>\n  </div>\n</form>\n\n<script text='text/javascript'>\ndocument.getElementById(\"8306994115733070077\").addEventListener(\"change\", function() {\n  var correct = (Math.abs(this.value - 2) <= 0);\n  var msgBox = document.getElementById('8306994115733070077_message');\n    if(correct) {\n    msgBox.innerHTML = \"<div class='pluto-output admonition note alert alert-success'><span> 👍&nbsp; Correct </span></div>\";\n    var explanation = document.getElementById(\"explanation_8306994115733070077\")\n    if (explanation != null) {\n       explanation.style.display = \"none\";\n    }\n  } else {\n    msgBox.innerHTML = \"<div class='pluto-output admonition alert alert-danger'><span>👎&nbsp; Incorrect </span></div>\";\n    var explanation = document.getElementById(\"explanation_8306994115733070077\")\n    if (explanation != null) {\n       explanation.style.display = \"block\";\n    }\n  }\n\n});\n\n</script>\n```\n:::\n:::\n\n\nDo the two methods converge to the exact same value?\n\n::: {.cell hold='true' execution_count=22}\n\n::: {.cell-output .cell-output-display execution_count=23}\n```{=html}\n<form class=\"mx-2 my-3 mw-100\" name='WeaveQuestion' data-id='10598212435956654482' data-controltype=''>\n  <div class='form-group '>\n    <div class='controls'>\n      <div class=\"form\" id=\"controls_10598212435956654482\">\n        <div style=\"padding-top: 5px\">\n    <div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_10598212435956654482_1\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_10598212435956654482\"\n              id=\"radio_10598212435956654482_1\" value=\"1\">\n      </input>\n      <span class=\"label-body px-1\">\n        Yes\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_10598212435956654482_2\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_10598212435956654482\"\n              id=\"radio_10598212435956654482_2\" value=\"2\">\n      </input>\n      <span class=\"label-body px-1\">\n        No\n      </span>\n    </label>\n</div>\n\n    \n        </div>\n      </div>\n      <div id='10598212435956654482_message' style=\"padding-bottom: 15px\"></div>\n    </div>\n  </div>\n</form>\n\n<script text='text/javascript'>\ndocument.querySelectorAll('input[name=\"radio_10598212435956654482\"]').forEach(function(rb) {\nrb.addEventListener(\"change\", function() {\n    var correct = rb.value == 1;\n    var msgBox = document.getElementById('10598212435956654482_message');\n      if(correct) {\n    msgBox.innerHTML = \"<div class='pluto-output admonition note alert alert-success'><span> 👍&nbsp; Correct </span></div>\";\n    var explanation = document.getElementById(\"explanation_10598212435956654482\")\n    if (explanation != null) {\n       explanation.style.display = \"none\";\n    }\n  } else {\n    msgBox.innerHTML = \"<div class='pluto-output admonition alert alert-danger'><span>👎&nbsp; Incorrect </span></div>\";\n    var explanation = document.getElementById(\"explanation_10598212435956654482\")\n    if (explanation != null) {\n       explanation.style.display = \"block\";\n    }\n  }\n\n})});\n\n</script>\n```\n:::\n:::\n\n\n###### Question\n\n\nLet `f(x) = exp(x) - x^4` and `x0=8.0`. How many steps (iterations) does it take for the secant method to converge using the default tolerances?\n\n::: {.cell hold='true' execution_count=23}\n\n::: {.cell-output .cell-output-display execution_count=24}\n```{=html}\n<form class=\"mx-2 my-3 mw-100\" name='WeaveQuestion' data-id='7706586215786066888' data-controltype=''>\n  <div class='form-group '>\n    <div class='controls'>\n      <div class=\"form\" id=\"controls_7706586215786066888\">\n        <div style=\"padding-top: 5px\">\n    </br>\n<div class=\"input-group\">\n    <input id=\"7706586215786066888\" type=\"number\" class=\"form-control\" placeholder=\"Numeric answer\">\n</div>\n\n    \n        </div>\n      </div>\n      <div id='7706586215786066888_message' style=\"padding-bottom: 15px\"></div>\n    </div>\n  </div>\n</form>\n\n<script text='text/javascript'>\ndocument.getElementById(\"7706586215786066888\").addEventListener(\"change\", function() {\n  var correct = (Math.abs(this.value - 10) <= 1);\n  var msgBox = document.getElementById('7706586215786066888_message');\n    if(correct) {\n    msgBox.innerHTML = \"<div class='pluto-output admonition note alert alert-success'><span> 👍&nbsp; Correct </span></div>\";\n    var explanation = document.getElementById(\"explanation_7706586215786066888\")\n    if (explanation != null) {\n       explanation.style.display = \"none\";\n    }\n  } else {\n    msgBox.innerHTML = \"<div class='pluto-output admonition alert alert-danger'><span>👎&nbsp; Incorrect </span></div>\";\n    var explanation = document.getElementById(\"explanation_7706586215786066888\")\n    if (explanation != null) {\n       explanation.style.display = \"block\";\n    }\n  }\n\n});\n\n</script>\n```\n:::\n:::\n\n\n###### Question\n\n\nLet `f(x) = exp(x) - x^4` and a starting bracket be `x0 = [8.9]`. Then calling `find_zero(f,x0, verbose=true)` will show that 49 steps are needed for exact bisection to converge. What about with the `Roots.Brent()` algorithm, which uses inverse quadratic steps when it can?\n\n\nIt takes how many steps?\n\n::: {.cell hold='true' execution_count=24}\n\n::: {.cell-output .cell-output-display execution_count=25}\n```{=html}\n<form class=\"mx-2 my-3 mw-100\" name='WeaveQuestion' data-id='12429425754659404857' data-controltype=''>\n  <div class='form-group '>\n    <div class='controls'>\n      <div class=\"form\" id=\"controls_12429425754659404857\">\n        <div style=\"padding-top: 5px\">\n    </br>\n<div class=\"input-group\">\n    <input id=\"12429425754659404857\" type=\"number\" class=\"form-control\" placeholder=\"Numeric answer\">\n</div>\n\n    \n        </div>\n      </div>\n      <div id='12429425754659404857_message' style=\"padding-bottom: 15px\"></div>\n    </div>\n  </div>\n</form>\n\n<script text='text/javascript'>\ndocument.getElementById(\"12429425754659404857\").addEventListener(\"change\", function() {\n  var correct = (Math.abs(this.value - 36) <= 1);\n  var msgBox = document.getElementById('12429425754659404857_message');\n    if(correct) {\n    msgBox.innerHTML = \"<div class='pluto-output admonition note alert alert-success'><span> 👍&nbsp; Correct </span></div>\";\n    var explanation = document.getElementById(\"explanation_12429425754659404857\")\n    if (explanation != null) {\n       explanation.style.display = \"none\";\n    }\n  } else {\n    msgBox.innerHTML = \"<div class='pluto-output admonition alert alert-danger'><span>👎&nbsp; Incorrect </span></div>\";\n    var explanation = document.getElementById(\"explanation_12429425754659404857\")\n    if (explanation != null) {\n       explanation.style.display = \"block\";\n    }\n  }\n\n});\n\n</script>\n```\n:::\n:::\n\n\nThe `Roots.A42()` method uses inverse cubic interpolation, as possible, how many steps does this method take to converge?\n\n::: {.cell hold='true' execution_count=25}\n\n::: {.cell-output .cell-output-display execution_count=26}\n```{=html}\n<form class=\"mx-2 my-3 mw-100\" name='WeaveQuestion' data-id='4182749320874801462' data-controltype=''>\n  <div class='form-group '>\n    <div class='controls'>\n      <div class=\"form\" id=\"controls_4182749320874801462\">\n        <div style=\"padding-top: 5px\">\n    </br>\n<div class=\"input-group\">\n    <input id=\"4182749320874801462\" type=\"number\" class=\"form-control\" placeholder=\"Numeric answer\">\n</div>\n\n    \n        </div>\n      </div>\n      <div id='4182749320874801462_message' style=\"padding-bottom: 15px\"></div>\n    </div>\n  </div>\n</form>\n\n<script text='text/javascript'>\ndocument.getElementById(\"4182749320874801462\").addEventListener(\"change\", function() {\n  var correct = (Math.abs(this.value - 3) <= 1);\n  var msgBox = document.getElementById('4182749320874801462_message');\n    if(correct) {\n    msgBox.innerHTML = \"<div class='pluto-output admonition note alert alert-success'><span> 👍&nbsp; Correct </span></div>\";\n    var explanation = document.getElementById(\"explanation_4182749320874801462\")\n    if (explanation != null) {\n       explanation.style.display = \"none\";\n    }\n  } else {\n    msgBox.innerHTML = \"<div class='pluto-output admonition alert alert-danger'><span>👎&nbsp; Incorrect </span></div>\";\n    var explanation = document.getElementById(\"explanation_4182749320874801462\")\n    if (explanation != null) {\n       explanation.style.display = \"block\";\n    }\n  }\n\n});\n\n</script>\n```\n:::\n:::\n\n\nThe large difference is due to how the tolerances are set within `Roots`. The `Brent method gets pretty close in a few steps, but takes a much longer time to get close enough for the default tolerances\n\n\n###### Question\n\n\nConsider this crazy function defined by:\n\n``` {.julia .cell-code}\nf(x) = cos(100*x)-4*erf(30*x-10)\n```\n\n\n(The `erf` function is the (error function](https://en.wikipedia.org/wiki/Error_function) and is in the `SpecialFunctions` package loaded with `CalculusWithJulia`.)\n\n\nMake a plot over the interval $[-3,3]$ to see why it is called \"crazy\".\n\n\nDoes `find_zero` find a zero to this function starting from $0$?\n\n::: {.cell hold='true' execution_count=27}\n\n::: {.cell-output .cell-output-display execution_count=27}\n```{=html}\n<form class=\"mx-2 my-3 mw-100\" name='WeaveQuestion' data-id='13468827789635773235' data-controltype=''>\n  <div class='form-group '>\n    <div class='controls'>\n      <div class=\"form\" id=\"controls_13468827789635773235\">\n        <div style=\"padding-top: 5px\">\n    <div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_13468827789635773235_1\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_13468827789635773235\"\n              id=\"radio_13468827789635773235_1\" value=\"1\">\n      </input>\n      <span class=\"label-body px-1\">\n        Yes\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_13468827789635773235_2\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_13468827789635773235\"\n              id=\"radio_13468827789635773235_2\" value=\"2\">\n      </input>\n      <span class=\"label-body px-1\">\n        No\n      </span>\n    </label>\n</div>\n\n    \n        </div>\n      </div>\n      <div id='13468827789635773235_message' style=\"padding-bottom: 15px\"></div>\n    </div>\n  </div>\n</form>\n\n<script text='text/javascript'>\ndocument.querySelectorAll('input[name=\"radio_13468827789635773235\"]').forEach(function(rb) {\nrb.addEventListener(\"change\", function() {\n    var correct = rb.value == 1;\n    var msgBox = document.getElementById('13468827789635773235_message');\n      if(correct) {\n    msgBox.innerHTML = \"<div class='pluto-output admonition note alert alert-success'><span> 👍&nbsp; Correct </span></div>\";\n    var explanation = document.getElementById(\"explanation_13468827789635773235\")\n    if (explanation != null) {\n       explanation.style.display = \"none\";\n    }\n  } else {\n    msgBox.innerHTML = \"<div class='pluto-output admonition alert alert-danger'><span>👎&nbsp; Incorrect </span></div>\";\n    var explanation = document.getElementById(\"explanation_13468827789635773235\")\n    if (explanation != null) {\n       explanation.style.display = \"block\";\n    }\n  }\n\n})});\n\n</script>\n```\n:::\n:::\n\n\nIf so, what is the value?\n\n::: {.cell hold='true' execution_count=28}\n\n::: {.cell-output .cell-output-display execution_count=28}\n```{=html}\n<form class=\"mx-2 my-3 mw-100\" name='WeaveQuestion' data-id='6015248520168034505' data-controltype=''>\n  <div class='form-group '>\n    <div class='controls'>\n      <div class=\"form\" id=\"controls_6015248520168034505\">\n        <div style=\"padding-top: 5px\">\n    </br>\n<div class=\"input-group\">\n    <input id=\"6015248520168034505\" type=\"number\" class=\"form-control\" placeholder=\"Numeric answer\">\n</div>\n\n    \n        </div>\n      </div>\n      <div id='6015248520168034505_message' style=\"padding-bottom: 15px\"></div>\n    </div>\n  </div>\n</form>\n\n<script text='text/javascript'>\ndocument.getElementById(\"6015248520168034505\").addEventListener(\"change\", function() {\n  var correct = (Math.abs(this.value - 0.3318660335745625) <= 0.001);\n  var msgBox = document.getElementById('6015248520168034505_message');\n    if(correct) {\n    msgBox.innerHTML = \"<div class='pluto-output admonition note alert alert-success'><span> 👍&nbsp; Correct </span></div>\";\n    var explanation = document.getElementById(\"explanation_6015248520168034505\")\n    if (explanation != null) {\n       explanation.style.display = \"none\";\n    }\n  } else {\n    msgBox.innerHTML = \"<div class='pluto-output admonition alert alert-danger'><span>👎&nbsp; Incorrect </span></div>\";\n    var explanation = document.getElementById(\"explanation_6015248520168034505\")\n    if (explanation != null) {\n       explanation.style.display = \"block\";\n    }\n  }\n\n});\n\n</script>\n```\n:::\n:::\n\n\nIf not, what is the reason?\n\n::: {.cell hold='true' execution_count=29}\n\n::: {.cell-output .cell-output-display execution_count=29}\n```{=html}\n<form class=\"mx-2 my-3 mw-100\" name='WeaveQuestion' data-id='1547679998945541892' data-controltype=''>\n  <div class='form-group '>\n    <div class='controls'>\n      <div class=\"form\" id=\"controls_1547679998945541892\">\n        <div style=\"padding-top: 5px\">\n    <div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_1547679998945541892_1\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_1547679998945541892\"\n              id=\"radio_1547679998945541892_1\" value=\"1\">\n      </input>\n      <span class=\"label-body px-1\">\n        The zero is a simple zero\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_1547679998945541892_2\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_1547679998945541892\"\n              id=\"radio_1547679998945541892_2\" value=\"2\">\n      </input>\n      <span class=\"label-body px-1\">\n        The zero is not a simple zero\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_1547679998945541892_3\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_1547679998945541892\"\n              id=\"radio_1547679998945541892_3\" value=\"3\">\n      </input>\n      <span class=\"label-body px-1\">\n        The function oscillates too much to rely on the tangent line approximation far from the zero\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_1547679998945541892_4\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_1547679998945541892\"\n              id=\"radio_1547679998945541892_4\" value=\"4\">\n      </input>\n      <span class=\"label-body px-1\">\n        We can find an answer\n      </span>\n    </label>\n</div>\n\n    \n        </div>\n      </div>\n      <div id='1547679998945541892_message' style=\"padding-bottom: 15px\"></div>\n    </div>\n  </div>\n</form>\n\n<script text='text/javascript'>\ndocument.querySelectorAll('input[name=\"radio_1547679998945541892\"]').forEach(function(rb) {\nrb.addEventListener(\"change\", function() {\n    var correct = rb.value == 4;\n    var msgBox = document.getElementById('1547679998945541892_message');\n      if(correct) {\n    msgBox.innerHTML = \"<div class='pluto-output admonition note alert alert-success'><span> 👍&nbsp; Correct </span></div>\";\n    var explanation = document.getElementById(\"explanation_1547679998945541892\")\n    if (explanation != null) {\n       explanation.style.display = \"none\";\n    }\n  } else {\n    msgBox.innerHTML = \"<div class='pluto-output admonition alert alert-danger'><span>👎&nbsp; Incorrect </span></div>\";\n    var explanation = document.getElementById(\"explanation_1547679998945541892\")\n    if (explanation != null) {\n       explanation.style.display = \"block\";\n    }\n  }\n\n})});\n\n</script>\n```\n:::\n:::\n\n\nDoes `find_zero` find a zero to this function starting from $1$?\n\n::: {.cell hold='true' execution_count=30}\n\n::: {.cell-output .cell-output-display execution_count=30}\n```{=html}\n<form class=\"mx-2 my-3 mw-100\" name='WeaveQuestion' data-id='15436875159156786907' data-controltype=''>\n  <div class='form-group '>\n    <div class='controls'>\n      <div class=\"form\" id=\"controls_15436875159156786907\">\n        <div style=\"padding-top: 5px\">\n    <div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_15436875159156786907_1\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_15436875159156786907\"\n              id=\"radio_15436875159156786907_1\" value=\"1\">\n      </input>\n      <span class=\"label-body px-1\">\n        Yes\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_15436875159156786907_2\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_15436875159156786907\"\n              id=\"radio_15436875159156786907_2\" value=\"2\">\n      </input>\n      <span class=\"label-body px-1\">\n        No\n      </span>\n    </label>\n</div>\n\n    \n        </div>\n      </div>\n      <div id='15436875159156786907_message' style=\"padding-bottom: 15px\"></div>\n    </div>\n  </div>\n</form>\n\n<script text='text/javascript'>\ndocument.querySelectorAll('input[name=\"radio_15436875159156786907\"]').forEach(function(rb) {\nrb.addEventListener(\"change\", function() {\n    var correct = rb.value == 2;\n    var msgBox = document.getElementById('15436875159156786907_message');\n      if(correct) {\n    msgBox.innerHTML = \"<div class='pluto-output admonition note alert alert-success'><span> 👍&nbsp; Correct </span></div>\";\n    var explanation = document.getElementById(\"explanation_15436875159156786907\")\n    if (explanation != null) {\n       explanation.style.display = \"none\";\n    }\n  } else {\n    msgBox.innerHTML = \"<div class='pluto-output admonition alert alert-danger'><span>👎&nbsp; Incorrect </span></div>\";\n    var explanation = document.getElementById(\"explanation_15436875159156786907\")\n    if (explanation != null) {\n       explanation.style.display = \"block\";\n    }\n  }\n\n})});\n\n</script>\n```\n:::\n:::\n\n\nIf so, what is the value?\n\n::: {.cell hold='true' execution_count=31}\n\n::: {.cell-output .cell-output-display execution_count=31}\n```{=html}\n<form class=\"mx-2 my-3 mw-100\" name='WeaveQuestion' data-id='1094189070004452833' data-controltype=''>\n  <div class='form-group '>\n    <div class='controls'>\n      <div class=\"form\" id=\"controls_1094189070004452833\">\n        <div style=\"padding-top: 5px\">\n    </br>\n<div class=\"input-group\">\n    <input id=\"1094189070004452833\" type=\"number\" class=\"form-control\" placeholder=\"Numeric answer\">\n</div>\n\n    \n        </div>\n      </div>\n      <div id='1094189070004452833_message' style=\"padding-bottom: 15px\"></div>\n    </div>\n  </div>\n</form>\n\n<script text='text/javascript'>\ndocument.getElementById(\"1094189070004452833\").addEventListener(\"change\", function() {\n  var correct = (Math.abs(this.value - -999.999) <= 0.001);\n  var msgBox = document.getElementById('1094189070004452833_message');\n    if(correct) {\n    msgBox.innerHTML = \"<div class='pluto-output admonition note alert alert-success'><span> 👍&nbsp; Correct </span></div>\";\n    var explanation = document.getElementById(\"explanation_1094189070004452833\")\n    if (explanation != null) {\n       explanation.style.display = \"none\";\n    }\n  } else {\n    msgBox.innerHTML = \"<div class='pluto-output admonition alert alert-danger'><span>👎&nbsp; Incorrect </span></div>\";\n    var explanation = document.getElementById(\"explanation_1094189070004452833\")\n    if (explanation != null) {\n       explanation.style.display = \"block\";\n    }\n  }\n\n});\n\n</script>\n```\n:::\n:::\n\n\nIf not, what is the reason?\n\n::: {.cell hold='true' execution_count=32}\n\n::: {.cell-output .cell-output-display execution_count=32}\n```{=html}\n<form class=\"mx-2 my-3 mw-100\" name='WeaveQuestion' data-id='1307209164501244380' data-controltype=''>\n  <div class='form-group '>\n    <div class='controls'>\n      <div class=\"form\" id=\"controls_1307209164501244380\">\n        <div style=\"padding-top: 5px\">\n    <div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_1307209164501244380_1\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_1307209164501244380\"\n              id=\"radio_1307209164501244380_1\" value=\"1\">\n      </input>\n      <span class=\"label-body px-1\">\n        The zero is a simple zero\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_1307209164501244380_2\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_1307209164501244380\"\n              id=\"radio_1307209164501244380_2\" value=\"2\">\n      </input>\n      <span class=\"label-body px-1\">\n        The zero is not a simple zero\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_1307209164501244380_3\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_1307209164501244380\"\n              id=\"radio_1307209164501244380_3\" value=\"3\">\n      </input>\n      <span class=\"label-body px-1\">\n        The function oscillates too much to rely on the tangent line approximations far from the zero\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_1307209164501244380_4\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_1307209164501244380\"\n              id=\"radio_1307209164501244380_4\" value=\"4\">\n      </input>\n      <span class=\"label-body px-1\">\n        We can find an answer\n      </span>\n    </label>\n</div>\n\n    \n        </div>\n      </div>\n      <div id='1307209164501244380_message' style=\"padding-bottom: 15px\"></div>\n    </div>\n  </div>\n</form>\n\n<script text='text/javascript'>\ndocument.querySelectorAll('input[name=\"radio_1307209164501244380\"]').forEach(function(rb) {\nrb.addEventListener(\"change\", function() {\n    var correct = rb.value == 3;\n    var msgBox = document.getElementById('1307209164501244380_message');\n      if(correct) {\n    msgBox.innerHTML = \"<div class='pluto-output admonition note alert alert-success'><span> 👍&nbsp; Correct </span></div>\";\n    var explanation = document.getElementById(\"explanation_1307209164501244380\")\n    if (explanation != null) {\n       explanation.style.display = \"none\";\n    }\n  } else {\n    msgBox.innerHTML = \"<div class='pluto-output admonition alert alert-danger'><span>👎&nbsp; Incorrect </span></div>\";\n    var explanation = document.getElementById(\"explanation_1307209164501244380\")\n    if (explanation != null) {\n       explanation.style.display = \"block\";\n    }\n  }\n\n})});\n\n</script>\n```\n:::\n:::\n\n\n",
    "supporting": [
      "more_zeros_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}