{
  "hash": "70eb380cc8e4c38c39dbb9cbf4614cea",
  "result": {
    "markdown": "# Functions $R^n \\rightarrow R^m$\n\n\n\nThis section uses these add-on packages:\n\n``` {.julia .cell-code}\nusing CalculusWithJulia\nusing Plots\nusing SymPy\nusing ForwardDiff\nusing LinearAlgebra\n```\n\n\n\n\nFor a scalar function $f: R^n \\rightarrow R$, the gradient of $f$, $\\nabla{f}$, is a function from $R^n \\rightarrow R^n$. Specializing to $n=2$, a function that for each point, $(x,y)$, assigns a vector $\\vec{v}$. This is an example of vector field. More generally, we  could have a [function](https://en.wikipedia.org/wiki/Multivariable_calculus) $f: R^n \\rightarrow R^m$, of which we have discussed many already:\n\n\n|         Mapping         |     Name      |       Visualize with        |       Notation       |\n|:-----------------------:|:-------------:|:---------------------------:|:--------------------:|\n|   $f: R\\rightarrow R$   |  univariate   | familiar graph of function  |         $f$          |\n|  $f: R\\rightarrow R^m$  | vector-valued |  space curve when n=2 or 3  | $\\vec{r}$, $\\vec{N}$ |\n|  $f: R^n\\rightarrow R$  |    scalar     |     a surface when n=2      |         $f$          |\n| $F: R^n\\rightarrow R^n$ | vector field  |   a vector field when n=2   |         $F$          |\n| $F: R^n\\rightarrow R^m$ | multivariable | n=2,m=3 describes a surface |     $F$, $\\Phi$      |\n\n\nAfter an example where the use of a multivariable function is of necessity, we discuss differentiation in general for a multivariable functions.\n\n\n## Vector fields\n\n\nWe have seen that the gradient of a scalar function, $f:R^2 \\rightarrow R$, takes a point in $R^2$ and associates a vector in $R^2$. As such $\\nabla{f}:R^2 \\rightarrow R^2$ is a vector field. A vector field  can be visualized by sampling a region and representing the field at those points. The details, as previously mentioned, are in the `vectorfieldplot` function of `CalculusWithJulia`.\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nF(u,v) = [-v, u]\nvectorfieldplot(F, xlim=(-5,5), ylim=(-5,5), nx=10, ny=10)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n![](vector_fields_files/figure-html/cell-5-output-1.svg){}\n:::\n:::\n\n\nThe optional arguments `nx=10` and `ny=10` determine the number of points on the grid that a vector will be plotted. These vectors are scaled to not overlap.\n\n\nVector field plots are useful for visualizing velocity fields, where a velocity vector is associated to each point; or streamlines, curves whose tangents are follow the velocity vector of a flow.  Vector fields are used in physics to model the electric field and the magnetic field. These are used to describe forces on objects within the field.\n\n\nThe three dimensional vector field is one way to illustrate a vector field, but there is an alternate using field lines. Like Euler's method, imagine starting at some point, $\\vec{r}$ in $R^3$. The field at that point is a vector indicating a direction of motion. Follow that vector for some infinitesimal amount, $d\\vec{r}$. From here repeat. The field curve would satisfy $\\vec{r}'(t) = F(\\vec{r}(t))$. Field curves only show direction, to indicate magnitude at a point, the convention is to use denser lines when the field is stronger.\n\n![Illustration of the magnetic field of the earth using field lines to indicate the field. From [Wikipedia](https://en.wikipedia.org/wiki/Magnetic_field). ](../differentiable_vector_calculus/figures/magnetic-field.png)\n\n\n\n---\n\n\nVector fields are also useful for other purposes, such as transformations, examples of which are a rotation or the conversion from polar to rectangular coordinates.\n\n\nFor transformations, a useful visualization is to plot curves where one variables is fixed. Consider the transformation from polar coordinates to cartesian coordinates $F(r, \\theta) = r \\langle\\cos(\\theta),\\sin(\\theta)\\rangle$. The following plot will show in blue fixed values of $r$ (circles) and in red fixed values of $\\theta$ (rays).\n\n::: {.cell hold='true' execution_count=6}\n``` {.julia .cell-code}\nF(r,theta) = r*[cos(theta), sin(theta)]\nF(v) = F(v...)\n\nrs = range(0, 2, length=5)\nthetas = range(0, pi/2, length=9)\n\nplot(legend=false, aspect_ratio=:equal)\nplot!(unzip(F.(rs, thetas'))..., color=:red)\nplot!(unzip(F.(rs', thetas))..., color=:blue)\n\npt = [1, pi/4]\nJ = ForwardDiff.jacobian(F, pt)\narrow!(F(pt...), J[:,1], linewidth=5, color=:red)\narrow!(F(pt...), J[:,2], linewidth=5, color=:blue)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n![](vector_fields_files/figure-html/cell-7-output-1.svg){}\n:::\n:::\n\n\nTo the plot, we added the partial derivatives with respect to $r$ (in red) and with respect to $\\theta$ (in blue). These are found with the soon-to-be discussed Jacobian. From the graph, you can see that these vectors are tangent vectors to the drawn curves.\n\n\n## Parametrically defined surfaces\n\n\nFor a one-dimensional curve we have several descriptions. For example, as the graph of a function $y=f(x)$; as a parametrically defined curve $\\vec{r}(t) = \\langle x(t), y(t)\\rangle$; or as a level curve of a scalar function $f(x,y) = c$.\n\n\nFor two-dimensional surfaces in three dimensions, we have discussed describing these in terms of a function $z = f(x,y)$ and as level curves of scalar functions: $c = f(x,y,z)$. They can also be described parametrically.\n\n\nWe pick a familiar case, to make this concrete: the unit sphere in $R^3$. We have\n\n\n  * It is described by two functions through $f(x,y) = \\pm \\sqrt{1 - (x^2 + y^2)}$.\n  * It is described by $f(x,y,z) = 1$, where $f(x,y,z) = x^2 + y^2 + z^2$.\n  * It can be described in terms of [spherical coordinates](https://en.wikipedia.org/wiki/Spherical_coordinate_system):\n\n\n\n$$\n\\Phi(\\theta, \\phi) = \\langle \\sin(\\phi)\\cos(\\theta), \\sin(\\phi)\\sin(\\theta), \\cos(\\phi) \\rangle,\n$$\n\n\nwith $\\theta$ the *azimuthal* angle and $\\phi$ the polar angle (measured down from the $z$ axis).\n\n\nThe function $\\Phi$ takes $R^2$ into $R^3$, so is a multivariable function.\n\n\nWhen a surface is described by a function, $z=f(x,y)$, then the gradient points (in the $x-y$ plane) in the direction of greatest increase of $f$. The vector $\\langle -f_x, -f_y, 1\\rangle$ is a normal.\n\n\nWhen a surface is described as a level curve, $f(x,y,z) = c$, then the gradient is *normal* to the surface.\n\n\nWhen a surface is described parametrically, there is no \"gradient.\" The *partial* derivatives are of interest, e.g., $\\partial{F}/\\partial{\\theta}$ and $\\partial{F}/\\partial{\\phi}$, vectors defined componentwise. These will be lie in the tangent plane of the surface, as they can be viewed as tangent vectors for parametrically defined curves on the surface. Their cross product will be *normal* to the surface. The magnitude of the cross product, which reflects the angle between the two partial derivatives, will be informative as to the surface area.\n\n\n### Plotting parametrized surfaces in `Julia`\n\n\nConsider the parametrically described surface above. How would it be plotted? Using the `Plots` package, the process is quite similar to how a surface described by a function is plotted, but the $z$ values must be computed prior to plotting.\n\n\nHere we define the parameterization using functions to represent each component:\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\nX(theta,phi) = sin(phi) * cos(theta)\nY(theta,phi) = sin(phi) * sin(theta)\nZ(theta,phi) = cos(phi)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\nZ (generic function with 1 method)\n```\n:::\n:::\n\n\nThen:\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\nthetas = range(0, stop=pi/2, length=50)\nphis   = range(0, stop=pi,   length=50)\n\nxs = [X(theta, phi) for theta in thetas, phi in phis]\nys = [Y(theta, phi) for theta in thetas, phi in phis]\nzs = [Z(theta, phi) for theta in thetas, phi in phis]\n\nsurface(xs, ys, zs)  ## see note\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n![](vector_fields_files/figure-html/cell-9-output-1.svg){}\n:::\n:::\n\n\n:::{.callout-note}\n## Note\n\n:::\n\nOnly *some* backends for `Plots` will produce this type of plot. Both `plotly()` and `pyplot()` will, but not `gr()`.\n\n\n:::{.callout-note}\n## Note\nPyPlot can  be used directly to make these surface plots: `import PyPlot; PyPlot.plot_surface(xs,ys,zs).\n\n:::\n\nInstead of the comprehension, broadcasting can be used\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\nsurface(X.(thetas, phis'), Y.(thetas, phis'), Z.(thetas, phis'))\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n![](vector_fields_files/figure-html/cell-10-output-1.svg){}\n:::\n:::\n\n\nIf the parameterization is presented as a function, broadcasting can be used to succintly plot\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\nPhi(theta, phi) = [X(theta, phi), Y(theta, phi), Z(theta, phi)]\n\nsurface(unzip(Phi.(thetas, phis'))...)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n![](vector_fields_files/figure-html/cell-11-output-1.svg){}\n:::\n:::\n\n\nThe partial derivatives of each component, $\\partial{\\Phi}/\\partial{\\theta}$ and $\\partial{\\Phi}/\\partial{\\phi}$, can be computed directly:\n\n\n\n$$\n\\begin{align*}\n\\partial{\\Phi}/\\partial{\\theta} &= \\langle -\\sin(\\phi)\\sin(\\theta), \\sin(\\phi)\\cos(\\theta),0 \\rangle,\\\\\n\\partial{\\Phi}/\\partial{\\phi} &= \\langle \\cos(\\phi)\\cos(\\theta), \\cos(\\phi)\\sin(\\theta), -\\sin(\\phi) \\rangle.\n\\end{align*}\n$$\n\n\nUsing `SymPy`, we can compute through:\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\n@syms theta phi\nout = [diff.(Phi(theta, phi), theta) diff.(Phi(theta, phi), phi)]\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n3×2 Matrix{Sym}:\n -sin(φ)⋅sin(θ)  cos(φ)⋅cos(θ)\n  sin(φ)⋅cos(θ)  sin(θ)⋅cos(φ)\n                    0            -sin(φ)\n```\n:::\n:::\n\n\nAt the point $(\\theta, \\phi) = (\\pi/12, \\pi/6)$ this evaluates to the following.\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code}\nsubs.(out, theta.=> PI/12, phi.=>PI/6) .|> N\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n3×2 Matrix{Real}:\n -0.12941     0.836516\n  0.482963    0.224144\n  0         -1//2\n```\n:::\n:::\n\n\nWe found numeric values, so that we can compare to the numerically identical values computed by the `jacobian` function from `ForwardDiff`:\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\npt = [pi/12, pi/6]\nout₁ = ForwardDiff.jacobian(v -> Phi(v...), pt)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n3×2 Matrix{Float64}:\n -0.12941    0.836516\n  0.482963   0.224144\n -0.0       -0.5\n```\n:::\n:::\n\n\nWhat this function computes exactly will be described next, but here we visualize the partial derivatives and see they lie in the tangent plane at the point:\n\n::: {.cell hold='true' execution_count=14}\n``` {.julia .cell-code}\nus, vs = range(0, pi/2, length=25), range(0, pi, length=25)\nxs, ys, zs = unzip(Phi.(us, vs'))\nsurface(xs, ys, zs, legend=false)\narrow!(Phi(pt...), out₁[:,1], linewidth=3)\narrow!(Phi(pt...), out₁[:,2], linewidth=3)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n![](vector_fields_files/figure-html/cell-15-output-1.svg){}\n:::\n:::\n\n\n## The total derivative\n\n\nInformally, the [total derivative](https://en.wikipedia.org/wiki/Total_derivative) at $a$ is the best linear approximation of the value of a function, $F$, near $a$ with respect to its arguments. If it exists, denote it $dF_a$.\n\n\nFor a function $F: R^n \\rightarrow R^m$ we have the total derivative at $\\vec{a}$ (a point or vector in $R^n$) is a matrix $J$ (a linear transformation)  taking vectors in $R^n$ and returning, under multiplication, vectors in $R^m$ (this matrix will be $m \\times n$), such that for some neighborhood of $\\vec{a}$, we have:\n\n\n\n$$\n\\lim_{\\vec{x} \\rightarrow \\vec{a}} \\frac{\\|F(\\vec{x}) - F(\\vec{a}) - J\\cdot(\\vec{x}-\\vec{a})\\|}{\\|\\vec{x} - \\vec{a}\\|} = \\vec{0}.\n$$\n\n\n(That is $\\|F(\\vec{x}) - F(\\vec{a}) - J\\cdot(\\vec{x}-\\vec{a})\\|=\\mathcal{o}(\\|\\vec{x}-\\vec{a}\\|)$.)\n\n\nIf for some $J$ the above holds, the function $F$ is said to be totally differentiable, and the matrix $J =J_F=dF_a$ is the total derivative.\n\n\nFor a multivariable function $F:R^n \\rightarrow R^m$, we may express the function in vector-valued form $F(\\vec{x}) = \\langle f_1(\\vec{x}), f_2(\\vec{x}),\\dots,f_m(\\vec{x})\\rangle$, each component a scalar function. Then, if the total derivative exists, it can be expressed by the [Jacobian](https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant):\n\n\n\n$$\nJ = \\left[\n\\begin{align*}\n\\frac{\\partial f_1}{\\partial x_1} &\\quad \\frac{\\partial f_1}{\\partial x_2} &\\dots&\\quad\\frac{\\partial f_1}{\\partial x_n}\\\\\n\\frac{\\partial f_2}{\\partial x_1} &\\quad \\frac{\\partial f_2}{\\partial x_2} &\\dots&\\quad\\frac{\\partial f_2}{\\partial x_n}\\\\\n&&\\vdots&\\\\\n\\frac{\\partial f_m}{\\partial x_1} &\\quad \\frac{\\partial f_m}{\\partial x_2} &\\dots&\\quad\\frac{\\partial f_m}{\\partial x_n}\n\\end{align*}\n\\right].\n$$\n\n\nThis may also be viewed as:\n\n\n\n$$\nJ = \\left[\n\\begin{align*}\n&\\nabla{f_1}'\\\\\n&\\nabla{f_2}'\\\\\n&\\quad\\vdots\\\\\n&\\nabla{f_m}'\n\\end{align*}\n\\right] =\n\\left[\n\\frac{\\partial{F}}{\\partial{x_1}}\\quad\n\\frac{\\partial{F}}{\\partial{x_2}} \\cdots\n\\frac{\\partial{F}}{\\partial{x_n}}\n\\right].\n$$\n\n\nThe latter representing a matrix of $m$ row vectors, each with $n$ components or as a matrix of $n$ column vectors, each with $m$ components.\n\n\n---\n\nAfter specializing the total derivative to the cases already discussed, we have:\n\n\n  * Univariate functions. Here $f'(t)$ is also univariate. Identifying $J$ with the $1 \\times 1$ matrix with component $f'(t)$, then the total derivative is just a restatement of the derivative existing.\n  * Vector-valued functions $\\vec{f}(t) = \\langle f_1(t), f_2(t), \\dots, f_m(t) \\rangle$, each component univariate. Then the derivative, $\\vec{f}'(t) = \\langle \\frac{df_1}{dt}, \\frac{df_2}{dt}, \\dots, \\frac{df_m}{dt} \\rangle$. The total derivative in this case, is a a $m \\times 1$ vector of partial derivatives, and since there is only $1$ variable, would be written without partials. So the two agree.\n  * Scalar functions $f(\\vec{x}) = a$ of type $R^n \\rightarrow R$. The\n\n\ndefinition of differentiability for $f$ involved existence of the partial derivatives and moreover, the fact that a limit like the above held with $\\nabla{f}(C) \\cdot \\vec{h}$ in place of $J\\cdot(\\vec{x}-\\vec{a})$. Here $\\vec{h}$ and $\\vec{x}-\\vec{a}$ are vectors in $R^n$. Were the dot product in $\\nabla{f}(C) \\cdot \\vec{h}$ expressed in matrix multiplication we would have for this case a $1 \\times n$ matrix of the correct form:\n\n\n\n$$\nJ = [\\nabla{f}'].\n$$\n\n\n  * For $f:R^2 \\rightarrow R$, the Hessian matrix, was the matrix of $2$nd partial derivatives. This may be viewed as the total derivative of the the gradient function, $\\nabla{f}$:\n\n\n\n$$\n\\text{Hessian} =\n\\left[\n\\begin{align*}\n\\frac{\\partial^2 f}{\\partial x^2}          &\\quad \\frac{\\partial^2 f}{\\partial x \\partial y}\\\\\n\\frac{\\partial^2 f}{\\partial y \\partial x} &\\quad \\frac{\\partial^2 f}{\\partial y \\partial y}\n\\end{align*}\n\\right]\n$$\n\n\nThis is equivalent to:\n\n\n\n$$\n\\left[\n\\begin{align*}\n\\frac{\\partial \\frac{\\partial f}{\\partial x}}{\\partial x} &\\quad \\frac{\\partial \\frac{\\partial f}{\\partial x}}{\\partial y}\\\\\n\\frac{\\partial \\frac{\\partial f}{\\partial y}}{\\partial x} &\\quad \\frac{\\partial \\frac{\\partial f}{\\partial y}}{\\partial y}\\\\\n\\end{align*}\n\\right].\n$$\n\n\nAs such, the total derivative is a generalization of what we have previously discussed.\n\n\n## The chain rule\n\n\nIf $G:R^k \\rightarrow R^n$ and $F:R^n \\rightarrow R^m$, then the composition $F\\circ G$ takes $R^k \\rightarrow R^m$. If all three functions are totally differentiable, then a chain rule will hold (total derivative of $F\\circ G$ at point $a$):\n\n\n\n$$\nd(F\\circ G)_a = dF_{G(a)} \\cdot dG_a\n\n$$\n\n\nIf correct, this has the same formulation as the chain rule for the univariate case: derivative of outer at the inner *times* the derivative of the inner.\n\n\nFirst we check that the dimensions are correct: We have $dF_{G(a)}$ (the total derivative of $F$ at the point $G(a)$) is an $m \\times n$ matrix and $dG_a$ (the total derivative of $G$ at the point $a$) is a $n \\times k$ matrix. The product of a $m \\times n$ matrix with a $n \\times k$ matrix is defined, and is a $m \\times k$ matrix, as is $d(F \\circ G)_a$.\n\n\nThe proof that the formula is correct uses the definition of totally differentiable written as\n\n\n\n$$\nF(b + \\vec{h}) - F(b) - dF_b\\cdot \\vec{h} = \\epsilon(\\vec{h}) \\vec{h},\n$$\n\n\nwhere $\\epsilon(h) \\rightarrow \\vec{0}$ as $h \\rightarrow \\vec{0}$.\n\n\nWe have, using this for *both* $F$ and $G$:\n\n\n\n$$\n\\begin{align*}\nF(G(a + \\vec{h})) - F(G(a)) &=\nF(G(a) + (dG_a \\cdot \\vec{h} + \\epsilon_G \\vec{h})) - F(G(a))\\\\\n&= F(G(a)) + dF_{G(a)} \\cdot (dG_a \\cdot \\vec{h} + \\epsilon_G \\vec{h}) \\\\\n&+ \\quad\\epsilon_F (dG_a \\cdot \\vec{h} + \\epsilon_G \\vec{h}) - F(G(a))\\\\\n&= dF_{G(a)} \\cdot (dG_a \\cdot \\vec{h})  +  dF_{G(a)} \\cdot (\\epsilon_G \\vec{h}) + \\epsilon_F (dG_a \\cdot \\vec{h}) + (\\epsilon_F \\cdot \\epsilon_G\\vec{h})\n\\end{align*}\n$$\n\n\nThe last line uses the linearity of $dF$ to isolate $dF_{G(a)} \\cdot (dG_a \\cdot \\vec{h})$. Factoring out $\\vec{h}$ and taking norms gives:\n\n\n\n$$\n\\begin{align*}\n\\frac{\\| F(G(a+\\vec{h})) - F(G(a)) - dF_{G(a)}dG_a \\cdot \\vec{h} \\|}{\\| \\vec{h} \\|} &=\n\\frac{\\|  dF_{G(a)}\\cdot(\\epsilon_G\\vec{h}) + \\epsilon_F (dG_a\\cdot \\vec{h}) + (\\epsilon_F\\cdot\\epsilon_G\\vec{h}) \\|}{\\| \\vec{h} \\|} \\\\\n&\\leq \\|  dF_{G(a)}\\cdot\\epsilon_G + \\epsilon_F (dG_a) + \\epsilon_F\\cdot\\epsilon_G \\|\\frac{\\|\\vec{h}\\|}{\\| \\vec{h} \\|}\\\\\n&\\rightarrow 0.\n\\end{align*}\n$$\n\n\n### Examples\n\n\nOur main use of the total derivative will be the change of variables in integration.\n\n\n##### Example: polar coordinates\n\n\nA point $(a,b)$ in the plane can be described in polar coordinates by a radius $r$ and polar angle $\\theta$. We can express this formally by $F:(a,b) \\rightarrow (r, \\theta)$ with\n\n\n\n$$\nr(a,b) = \\sqrt{a^2 + b^2}, \\quad\n\\theta(a,b) = \\tan^{-1}(b/a),\n$$\n\n\nthe latter assuming the point is in quadrant I or IV (though `atan(y,x)` will properly handle the other quadrants). The Jacobian of this transformation may be found with\n\n::: {.cell execution_count=15}\n``` {.julia .cell-code}\n@syms a::real b::real\n\nrⱼ = sqrt(a^2 + b^2)\nθⱼ = atan(b/a)\n\nJac = Sym[diff.(rⱼ, [a,b])';        # [∇f_1'; ∇f_2']\n          diff.(θⱼ, [a,b])']\n\nsimplify.(Jac)\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n2×2 Matrix{Sym}:\n a*conjugate(1/sqrt(a^2 + b^2))  b*conjugate(1/sqrt(a^2 + b^2))\n                 -b/(a^2 + b^2)                   a/(a^2 + b^2)\n```\n:::\n:::\n\n\n`SymPy` array objects have a `jacobian` method to make this easier to do. The calling style is Python-like, using `object.method(...)`:\n\n::: {.cell execution_count=16}\n``` {.julia .cell-code}\n[rⱼ, θⱼ].jacobian([a, b])\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n2×2 Matrix{Sym}:\n      a/sqrt(a^2 + b^2)    b/sqrt(a^2 + b^2)\n -b/(a^2*(1 + b^2/a^2))  1/(a*(1 + b^2/a^2))\n```\n:::\n:::\n\n\nThe determinant, of geometric interest, will be\n\n::: {.cell execution_count=17}\n``` {.julia .cell-code}\ndet(Jac) |> simplify\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```{=html}\n<span class=\"math-left-align\" style=\"padding-left: 4px; width:0; float:left;\"> \n\\[\n\\overline{\\frac{1}{\\sqrt{a^{2} + b^{2}}}}\n\\]\n</span>\n```\n:::\n:::\n\n\nThe determinant is of interest, as the linear mapping represented by the Jacobian changes the area of the associated coordinate vectors. The determinant describes ow this area changes, as a multiplying factor.\n\n\n##### Example Spherical Coordinates\n\n\nIn $3$ dimensions a point can be described by (among other ways):\n\n\n  * Cartesian coordinates: three coordinates relative to the $x$, $y$, and $z$ axes as $(a,b,c)$.\n  * Spherical coordinates: a radius, $r$, an azimuthal angle $\\theta$, and a polar angle\n\n\n\n$$\n\\phi\n$$\n\n\nmeasured down from the $z$ axes.  (We use the mathematics naming convention, the physics one has $\\phi$ and $\\theta$ reversed.)\n\n\n  * Cylindrical coordinates: a radius, $r$, a polar angle $\\theta$, and height $z$.\n\n\nSome mappings are:\n\n\n| Cartesian (x,y,z) | Spherical ($r$, $\\theta$, $\\phi$) | Cylindrical ($r$, $\\theta$, $z$) |\n|:-----------------:|:---------------------------------:|:--------------------------------:|\n|     (1, 1, 0)     |    $(\\sqrt{2}, \\pi/4, \\pi/2)$     |      $(\\sqrt{2},\\pi/4, 0)$       |\n|     (0, 1, 1)     |      $(\\sqrt{2}, 0, \\pi/4)$       |        $(\\sqrt{2}, 0, 1)$        |\n\n---\n\n\nFormulas can be found to convert between the different systems, here are a few written as multivariable functions:\n\n::: {.cell execution_count=18}\n``` {.julia .cell-code}\nfunction spherical_from_cartesian(x,y,z)\n    r = sqrt(x^2 + y^2 + z^2)\n    theta = atan(y/x)\n    phi = acos(z/r)\n    [r, theta, phi]\nend\n\nfunction cartesian_from_spherical(r, theta, phi)\n    x = r*sin(phi)*cos(theta)\n    y = r*sin(phi)*sin(theta)\n    z = r*cos(phi)\n    [x, y, z]\nend\n\nfunction cylindrical_from_cartesian(x, y, z)\n    r = sqrt(x^2 + y^2)\n    theta = atan(y/x)\n    z = z\n    [r, theta, z]\nend\n\nfunction cartesian_from_cylindrical(r, theta, z)\n    x = r*cos(theta)\n    y = r*sin(theta)\n    z = z\n    [x, y, z]\nend\n\nspherical_from_cartesian(v) = spherical_from_cartesian(v...)\ncartesian_from_spherical(v) = cartesian_from_spherical(v...)\ncylindrical_from_cartesian(v)= cylindrical_from_cartesian(v...)\ncartesian_from_cylindrical(v) = cartesian_from_cylindrical(v...)\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\ncartesian_from_cylindrical (generic function with 2 methods)\n```\n:::\n:::\n\n\nThe Jacobian of a transformation can be found from these conversions. For example, the conversion from spherical to cartesian would have Jacobian computed by:\n\n::: {.cell execution_count=19}\n``` {.julia .cell-code}\n@syms r::real\n\nex1 = cartesian_from_spherical(r, theta, phi)\nJ1 = ex1.jacobian([r, theta, phi])\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\n3×3 Matrix{Sym}:\n sin(φ)⋅cos(θ)  -r⋅sin(φ)⋅sin(θ)  r⋅cos(φ)⋅cos(θ)\n sin(φ)⋅sin(θ)   r⋅sin(φ)⋅cos(θ)  r⋅sin(θ)⋅cos(φ)\n            cos(φ)                       0            -r⋅sin(φ)\n```\n:::\n:::\n\n\nThis has determinant:\n\n::: {.cell execution_count=20}\n``` {.julia .cell-code}\ndet(J1) |> simplify\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```{=html}\n<span class=\"math-left-align\" style=\"padding-left: 4px; width:0; float:left;\"> \n\\[\n- r^{2} \\sin{\\left(\\phi \\right)}\n\\]\n</span>\n```\n:::\n:::\n\n\nThere is no function to convert from spherical to cylindrical above, but clearly one can be made by *composition*:\n\n::: {.cell execution_count=21}\n``` {.julia .cell-code}\ncylindrical_from_spherical(r, theta, phi) =\n    cylindrical_from_cartesian(cartesian_from_spherical(r, theta, phi)...)\ncylindrical_from_spherical(v) = cylindrical_from_spherical(v...)\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\ncylindrical_from_spherical (generic function with 2 methods)\n```\n:::\n:::\n\n\nFrom this composition, we could compute the Jacobian directly, as with:\n\n::: {.cell execution_count=22}\n``` {.julia .cell-code}\nex2 = cylindrical_from_spherical(r, theta, phi)\nJ2 = ex2.jacobian([r, theta, phi])\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\n3×3 Matrix{Sym}:\n (r*sin(phi)^2*sin(theta)^2 + r*sin(phi)^2*cos(theta)^2)/sqrt(r^2*sin(phi)^2*sin(theta)^2 + r^2*sin(phi)^2*cos(theta)^2)  …  (r^2*sin(phi)*sin(theta)^2*cos(phi) + r^2*sin(phi)*cos(phi)*cos(theta)^2)/sqrt(r^2*sin(phi)^2*sin(theta)^2 + r^2*sin(phi)^2*cos(theta)^2)\n                                                                                                                       0                                                                                                                                             0\n                                                                                                                cos(φ)                                                                                                                                   -r⋅sin(φ)\n```\n:::\n:::\n\n\nNow to see that this last expression could have been found by the *chain rule*. To do this we need to find the Jacobian of each function; evaluate them at the proper places; and, finally, multiply the matrices. The `J1` object, found above, does one Jacobian. We now need to find that of `cylindrical_from_cartesian`:\n\n::: {.cell execution_count=23}\n``` {.julia .cell-code}\n@syms x::real y::real z::real\nex3 = cylindrical_from_cartesian(x, y, z)\nJ3 = ex3.jacobian([x,y,z])\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\n3×3 Matrix{Sym}:\n      x/sqrt(x^2 + y^2)    y/sqrt(x^2 + y^2)  0\n -y/(x^2*(1 + y^2/x^2))  1/(x*(1 + y^2/x^2))  0\n                      0                    0  1\n```\n:::\n:::\n\n\nThe chain rule is not simply `J3 * J1` in the notation above, as the `J3` matrix must be evaluated at \"`G(a)`\", which is `ex1` from above:\n\n::: {.cell execution_count=24}\n``` {.julia .cell-code}\nJ3_Ga = subs.(J3, x => ex1[1], y => ex1[2], z => ex1[3]) .|> simplify  # the dots are important\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\n3×3 Matrix{Sym}:\n r*sin(phi)*cos(theta)/(sqrt(sin(phi)^2)*Abs(r))  …  0\n                        -sin(theta)/(r*sin(phi))     0\n                                               0     1\n```\n:::\n:::\n\n\nThe chain rule now says this product should be equivalent to `J2` above:\n\n::: {.cell execution_count=25}\n``` {.julia .cell-code}\nJ3_Ga * J1\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\n3×3 Matrix{Sym}:\n r*sin(phi)^2*sin(theta)^2/(sqrt(sin(phi)^2)*Abs(r)) + r*sin(phi)^2*cos(theta)^2/(sqrt(sin(phi)^2)*Abs(r))  …  r^2*sin(phi)*sin(theta)^2*cos(phi)/(sqrt(sin(phi)^2)*Abs(r)) + r^2*sin(phi)*cos(phi)*cos(theta)^2/(sqrt(sin(phi)^2)*Abs(r))\n                                                                                                         0                                                                                                                               0\n                                                                                                  cos(φ)                                                                                                                     -r⋅sin(φ)\n```\n:::\n:::\n\n\nThe two are equivalent after simplification, as seen here:\n\n::: {.cell execution_count=26}\n``` {.julia .cell-code}\nJ3_Ga * J1 - J2 .|> simplify\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\n3×3 Matrix{Sym}:\n 0  0  0\n 0  0  0\n 0  0  0\n```\n:::\n:::\n\n\n##### Example\n\n\nThe above examples were done symbolically. Performing the calculation numerically is quite similar. The `ForwardDiff` package has a gradient function to find the gradient at a point. The `CalculusWithJulia` package extends this to take a gradient of a function and return a function, also called `gradient`. This is defined along the lines of:\n\n``` {.julia .cell-code}\ngradient(f::Function) = x -> ForwardDiff.gradient(f, x)\n```\n\n\n(though more flexibly, as either  vector or a separate arguments can be used.)\n\n\nWith this, defining a Jacobian function *could* be done like:\n\n``` {.julia .cell-code}\nfunction Jacobian(F, x)\n    n = length(F(x...))\n    grads = [gradient(x -> F(x...)[i])(x) for i in 1:n]\n    vcat(grads'...)\nend\n```\n\n\nBut, like `SymPy`, `ForwardDiff` provides a `jacobian` function directly, so we will use that; it requires a function definition where a vector is passed in and is called by `ForwardDiff.jacobian`. (The `ForwardDiff` package does not export its methods, they are qualified using the module name.)\n\n\nUsing the above functions, we can verify the last example at a point:\n\n::: {.cell execution_count=29}\n``` {.julia .cell-code}\nrtp = [1, pi/3, pi/4]\nForwardDiff.jacobian(cylindrical_from_spherical, rtp)\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\n3×3 Matrix{Float64}:\n 0.707107  0.0   0.707107\n 0.0       1.0   0.0\n 0.707107  0.0  -0.707107\n```\n:::\n:::\n\n\nThe chain rule gives the same answer up to roundoff error:\n\n::: {.cell execution_count=30}\n``` {.julia .cell-code}\nForwardDiff.jacobian(cylindrical_from_cartesian, cartesian_from_spherical(rtp)) * ForwardDiff.jacobian(cartesian_from_spherical, rtp)\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\n3×3 Matrix{Float64}:\n 0.707107     0.0   0.707107\n 5.55112e-17  1.0   5.55112e-17\n 0.707107     0.0  -0.707107\n```\n:::\n:::\n\n\n##### Example: The Inverse Function Theorem\n\n\nFor a change of variable problem, $F:R^n \\rightarrow R^n$, the determinant of the Jacobian quantifies how volumes get modified under the transformation. When this determinant is *non*zero, then more can be said. The [Inverse Function Theorem](https://en.wikipedia.org/wiki/Inverse_function_theorem) states\n\n\n> if  $F$ is a continuously differentiable function from an open set of $R^n$ into $R^n$and the total derivative is invertible at a point $p$ (i.e., the Jacobian determinant of $F$ at $p$ is non-zero), then $F$ is invertible near $p$. That is, an inverse function to $F$ is defined on some neighborhood of $q$, where $q=F(p)$. Further, $F^{-1}$ will be continuously differentiable at $q$ with $J_{F^{-1}}(q) = [J_F(p)]^{-1}$, the latter being the matrix inverse. Taking determinants, $\\det(J_{F^{-1}}(q)) = 1/\\det(J_F(p))$.\n\n\n\nAssuming $F^{-1}$ exists, we can verify the last part from the chain rule, in an identical manner to the univariate case, starting with $F^{-1} \\circ F$ being the identity, we would have:\n\n\n\n$$\nJ_{F^{-1}\\circ F}(p) = I,\n$$\n\n\nwhere $I$ is the *identity* matrix with entry $a_{ij} = 1$ when $i=j$ and $0$ otherwise.\n\n\nBut the chain rule then says $J_{F^{-1}}(F(p)) J_F(p) = I$. This implies the two matrices are inverses to each other, and using the multiplicative mapping property of the determinant will also imply the determinant relationship.\n\n\nThe theorem is an existential theorem, in that it implies $F^{-1}$ exists, but doesn't indicate how to find it. When we have an inverse though, we can verify the properties implied.\n\n\nThe transformation examples have inverses indicated. Using one of these we can verify things at a point, as done in the following:\n\n::: {.cell execution_count=31}\n``` {.julia .cell-code}\np = [1, pi/3, pi/4]\nq = cartesian_from_spherical(p)\n\nA1 = ForwardDiff.jacobian(spherical_from_cartesian, q)    # J_F⁻¹(q)\nA2 = ForwardDiff.jacobian(cartesian_from_spherical, p)    # J_F(p)\n\nA1 * A2\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\n3×3 Matrix{Float64}:\n 1.0          0.0  0.0\n 5.55112e-17  1.0  5.55112e-17\n 0.0          0.0  1.0\n```\n:::\n:::\n\n\nUp to roundoff error, this is the identity matrix. As for the relationship between the determinants, up to roundoff error the two are related, as expected:\n\n::: {.cell execution_count=32}\n``` {.julia .cell-code}\ndet(A1), 1/det(A2)\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```\n(-1.4142135623730956, -1.4142135623730951)\n```\n:::\n:::\n\n\n##### Example: Implicit Differentiation, the Implicit Function Theorem\n\n\nThe technique of *implicit differentiation* is a useful one, as it allows derivatives of more complicated expressions to be found. The main idea, expressed here with three variables is if an equation may be viewed as $F(x,y,z) = c$, $c$ a constant, then $z=\\phi(x,y)$ may be viewed as a function of $x$ and $y$. Hence, we can use the chain rule to find: $\\partial z / \\partial x$ and $\\partial z /\\partial x$. Let $G(x,y) = \\langle x, y, \\phi(x,y) \\rangle$ and then differentiation $(F \\circ G)(x,y) = c$:\n\n\n\n$$\n\\begin{align*}\n0 &= dF_{G(x,y)} \\circ dG_{\\langle x, y\\rangle}\\\\\n&= [\\frac{\\partial F}{\\partial x}\\quad \\frac{\\partial F}{\\partial y}\\quad \\frac{\\partial F}{\\partial z}](G(x,y)) \\cdot\n\\left[\\begin{array}{}\n1 & 0\\\\\n0 & 1\\\\\n\\frac{\\partial \\phi}{\\partial x} & \\frac{\\partial \\phi}{\\partial y}\n\\end{array}\\right].\n\\end{align*}\n$$\n\n\nSolving yields\n\n\n\n$$\n\\frac{\\partial \\phi}{\\partial x} = -\\frac{\\partial F/\\partial x}{\\partial F/\\partial z},\\quad\n\\frac{\\partial \\phi}{\\partial y} = -\\frac{\\partial F/\\partial y}{\\partial F/\\partial z}.\n$$\n\n\nWhere the right hand side of each is evaluated at $G(x,y)$.\n\n\nWhen can it be reasonably assumed that such a function $z= \\phi(x,y)$ exists?\n\n\nThe [Implicit Function Theorem](https://en.wikipedia.org/wiki/Implicit_function_theorem) provides a statement (slightly abridged here):\n\n\n> Let $F:R^{n+m} \\rightarrow R^m$ be a continuously differentiable function and let $R^{n+m}$ have (compactly defined) coordinates $\\langle \\vec{x}, \\vec{y} \\rangle$, Fix a point $\\langle \\vec{a}, \\vec{b} \\rangle$ with $F(\\vec{a}, \\vec{b}) = \\vec{0}$. Let $J_{F, \\vec{y}}(\\vec{a}, \\vec{b})$ be the Jacobian restricted to *just* the $y$ variables. ($J$ is $m \\times m$.) If this matrix has non-zero determinant (it is invertible), then there exists an open set $U$ containing $\\vec{a}$ and a *unique* continuously differentiable function $G: U \\subset R^n \\rightarrow R^m$ such that $G(\\vec{a}) = \\vec{b}$, $F(\\vec{x}, G(\\vec{x})) = 0$ for $\\vec x$ in $U$. Moreover, the partial derivatives of $G$ are given by the matrix product:\n>\n> $\\frac{\\partial G}{\\partial x_j}(\\vec{x}) = - [J_{F, \\vec{y}}(x, F(\\vec{x}))]^{-1} \\left[\\frac{\\partial F}{\\partial x_j}(x, G(\\vec{x}))\\right].$\n\n\n\n---\n\nSpecializing to our case above, we have $f:R^{2+1}\\rightarrow R^1$ and $\\vec{x} = \\langle a, b\\rangle$ and $\\phi:R^2 \\rightarrow R$. Then\n\n\n\n$$\n[J_{f, \\vec{y}}(x, g(\\vec{x}))] = [\\frac{\\partial f}{\\partial z}(a, b, \\phi(a,b)],\n$$\n\n\na $1\\times 1$ matrix, identified as a scalar, so inversion is just the reciprocal. So the formula, becomes, say for $x_1 = x$:\n\n\n\n$$\n\\frac{\\partial \\phi}{\\partial x}(a, b) = - \\frac{\\frac{\\partial{f}}{\\partial{x}}(a, b,\\phi(a,b))}{\\frac{\\partial{f}}{\\partial{z}}(a, b, \\phi(a,b))},\n$$\n\n\nas expressed above. Here invertibility is simply a non-zero value, and is needed for the division. In general, we see inverse (the $J^{-1}$) is necessary to express the answer.\n\n\nUsing this, we can answer questions like the following (as we did before) on a more solid ground:\n\n\nLet $x^2/a^2 + y^2/b^2 + z^2/c^2 = 1$ be an equation describing an ellipsoid. Describe the tangent plane at a point on the ellipse.\n\n\nWe would like to express the tangent plane in terms of $\\partial{z}/\\partial{x}$ and $\\partial{z}/\\partial{y}$, which we can do through:\n\n\n\n$$\n\\frac{2x}{a^2} + \\frac{2z}{c^2} \\frac{\\partial{z}}{\\partial{x}} = 0, \\quad\n\\frac{2y}{a^2} + \\frac{2z}{c^2} \\frac{\\partial{z}}{\\partial{y}} = 0.\n$$\n\n\nSolving, we get\n\n\n\n$$\n\\frac{\\partial{z}}{\\partial{x}} = -\\frac{2x}{a^2}\\frac{c^2}{2z},\n\\quad\n\\frac{\\partial{z}}{\\partial{y}} = -\\frac{2y}{a^2}\\frac{c^2}{2z},\n$$\n\n\n*provided* $z \\neq 0$. At $z=0$ the tangent plane exists, but we can't describe it in this manner, as it is vertical. However, the choice of variables to use is not fixed in the theorem, so if $x \\neq 0$ we can express $x = x(y,z)$ and express the tangent plane in terms of $\\partial{x}/\\partial{y}$ and $\\partial{x}/\\partial{z}$. The answer is similar to the above, and we won't repeat. Similarly, should $x = z = 0$, the $y \\neq 0$ and we can use an implicit definition $y = y(x,z)$ and express the tangent plane through  $\\partial{y}/\\partial{x}$ and $\\partial{y}/\\partial{z}$.\n\n\n##### Example: Lagrange multipliers in more dimensions\n\n\nConsider now the problem of maximizing $f:R^n \\rightarrow R$ subject to $k < n$ constraints $g_1(\\vec{x}) = c_1, g_2(\\vec{x}) = c_2, \\dots, g_{k}(\\vec{x}) = c_{k}$. For $n=1$ and $2$, we saw that if all derivatives exist, then a *necessary* condition to be at a maximum is that $\\nabla{f}$ can be written as $\\lambda_1 \\nabla{g_1}$ ($n=1$) or $\\lambda_1 \\nabla{g_1} + \\lambda_2 \\nabla{g_2}$. The key observation is that the gradient of $f$ must have no projection on the intersection of the tangent planes found by linearizing $g_i$.\n\n\nThe same thing holds in dimension $n > 2$: Let $\\vec{x}_0$ be a point where $f(\\vec{x})$ is maximum subject to the $p$ constraints. We want to show that $\\vec{x}_0$ must satisfy:\n\n\n\n$$\n\\nabla{f}(\\vec{x}_0) = \\sum \\lambda_i \\nabla{g_i}(\\vec{x}_0).\n$$\n\n\nBy considering $-f$, the same holds for a minimum.\n\n\nWe follow the sketch of [Sawyer](https://www.math.wustl.edu/~sawyer/handouts/LagrangeMult.pdf).\n\n\nUsing Taylor's theorem, we have $f(\\vec{x} + h \\vec{y}) = f(\\vec{x}) + h \\vec{y}\\cdot\\nabla{f} + h^2\\vec{c}$, for some $\\vec{c}$. If $h$ is small enough, this term can be ignored.\n\n\nThe tangent \"plane\" for each constraint, $g_i(\\vec{x}) = c_i$, is orthogonal to the gradient vector $\\nabla{g_i}(\\vec{x})$. That is, $\\nabla{g_i}(\\vec{x})$ is orthogonal to the level-surface formed by the constraint $g_i(\\vec{x}) = 0$. Let $A$ be the set of all *linear* combinations of $\\nabla{g_i}$, that are possible: $\\lambda_1 g_1(\\vec{x}) + \\lambda_2 g_2(\\vec{x}) + \\cdots + \\lambda_p g_p(\\vec{x})$, as in the statement. Through projection, we can write $\\nabla{f}(\\vec{x}_0) = \\vec{a} + \\vec{b}$, where $\\vec{a}$ is in $A$ and $\\vec{b}$ is *orthogonal* to $A$.\n\n\nLet $\\vec{r}(t)$ be a parameterization of a path through the intersection of the $p$ tangent planes that goes through $\\vec{x}_0$ at $t_0$ *and* $\\vec{b}$ is parallel to  $\\vec{x}_0'(t_0)$. (The implicit function theorem would guarantee this path.)\n\n\nIf we consider $f(\\vec{x}_0 + h \\vec{b})$ for small $h$, then unless $\\vec{b} \\cdot \\nabla{f} = 0$, the function would increase in the direction of $\\vec{b}$ due to the $h \\vec{b}\\cdot\\nabla{f}$ term in the approximating Taylor series. That is, $\\vec{x}_0$ would not be a maximum on the constraint. So at $\\vec{x}_0$ this directional derivative is $0$.\n\n\nThen we have the directional derivative in the direction of $b$ is $\\vec{0}$, as the gradient\n\n\n\n$$\n\\vec{0} = \\vec{b} \\cdot \\nabla{f}(\\vec{x}_0) = \\vec{b} \\cdot (\\vec{a} + \\vec{b}) = \\vec{b}\\cdot \\vec{a} + \\vec{b}\\cdot\\vec{b} = \\vec{b}\\cdot\\vec{b},\n$$\n\n\nor $\\| \\vec{b} \\| = 0$ and $\\nabla{f}(\\vec{x}_0)$ must lie in the plane $A$.\n\n---\n\n\nHow does the implicit function theorem guarantee a parameterization of a curve along the constraint in the direction of $b$?\n\n\nA formal proof requires a bit of linear algebra, but here we go. Let $G(\\vec{x}) = \\langle g_1(\\vec{x}), g_2(\\vec{x}), \\dots, g_k(\\vec{x}) \\rangle$. Then $G(\\vec{x}) = \\vec{c}$ encodes the constraint. The tangent planes are orthogonal to each $\\nabla{g_i}$, so using matrix notation, the intersection of the tangent planes is any vector $\\vec{h}$ satisfying $J_G(\\vec{x}_0) \\vec{h} = 0$. Let $k = n - 1 - p$. If $k > 0$, there will be $k$ vectors *orthogonal* to each of $\\nabla{g_i}$ and $\\vec{b}$. Call these $\\vec{v}_j$. Then define additional constraints $h_j(\\vec{x}) = \\vec{v}_j \\cdot \\vec{x} = 0$. Let $H(x_1, x_2, \\dots, x_n) = \\langle g_1, g_2, \\dots, g_p, h_1, \\dots, h_{n-1-p}\\rangle$. $H:R^{1 + (n-1)} \\rightarrow R^{n-1}$. Let $H(x_1, \\dots, x_n) = H(x, \\vec{y})$ The $H$ *restricted* to the $\\vec{y}$ variables is a function from $R^{n-1}\\rightarrow R^{n-1}$. *If* this restricted function has a Jacobian with non-zero determinant, then there exists a $\\vec\\phi(x): R \\rightarrow R^{n-1}$ with $H(x, \\vec\\phi(x)) = \\vec{c}$. Let $\\vec{r}(t) = \\langle t, \\phi_1(t), \\dots, \\phi_{n-1}(t)\\rangle$. Then $(H\\circ\\vec{r})(t) = \\vec{c}$, so by the chain rule $d_H(\\vec{r}) d\\vec{r} = 0$. But $dH = [\\nabla{g_1}'; \\nabla{g_2}' \\dots;\\nabla{g_p}', v_1';\\dots;v_{n-1-p}']$ (A matrix of row vectors). The condition $dH(\\vec{r}) d\\vec{r} = \\vec{0}$ is equivalent to saying $d\\vec{r}$ is *orthogonal* to the row vectors in $dH$. A *basis* for $R^n$ are these vectors and $\\vec{b}$, so $\\vec{r}$ and $\\vec{b}$ must be parallel.\n\n\n##### Example\n\n\nWe apply this to two problems, also from Sawyer. First, let $n > 1$ and $f(x_1, \\dots, x_n) = \\sum x_i^2$. Minimize this subject to the constraint $\\sum x_i = 1$. This one constraint means an answer must satisfy $\\nabla{L} = \\vec{0}$ where\n\n\n\n$$\nL(x_1, \\dots, x_n, \\lambda) = \\sum x_i^2 + \\lambda \\sum x_i - 1.\n$$\n\n\nTaking $\\partial/\\partial{x_i}$ we have $2x_i + \\lambda = 0$, so $x_i = \\lambda/2$, a constant. From the constraint, we see $x_i = 1/n$. This does not correspond to a  maximum, but a minimum. A maximum would be at point on the constraint such as $\\langle 1, 0, \\dots, 0\\rangle$, which gives a value of $1$ for $f$, not $n \\times 1/n^2 = 1/n$.\n\n\n##### Example\n\n\nIn statistics, there are different ways to define the best estimate for a population parameter based on the data. That is, suppose $X_1, X_2, \\dots, X_n$ are random variables. The population parameters of interest here are the mean $E(X_i) = \\mu$ and the variance $Var(X_i) = \\sigma_i^2$. (The mean is assumed to be the same for all, but the variance need not be.) What should someone use to *estimate* $\\mu$ using just the sample values $X_1, X_2, \\dots, X_n$? The average, $(X_1 + \\cdots + X_n)/n$ is a well known estimate, but is it the \"best\" in some sense for this set up? Here some variables are more variable, should they count the same, more, or less in the weighting for the estimate?\n\n\nIn Sawyer, we see an example of applying the Lagrange multiplier method to the best linear unbiased estimator (BLUE).  The BLUE is a choice of coefficients $a_i$ such that $Var(\\sum a_i X_i)$ is smallest subject to the constraint $E(\\sum a_i X_i) = \\mu$.\n\n\nThe BLUE *minimizes* the *variance* of the estimator. (This is the *B*est part of BLUE). The estimator, $\\sum a_i X_i$, is *L*inear. The constraint is that the estimator has theoretical mean given by $\\mu$. (This is the *Un*biased part of BLUE.)\n\n\nGoing from statistics to mathematics, we use formulas for *independent* random variables to restate this problem mathematically as:\n\n\n\n$$\n\\text{Minimize } \\sum a_i^2 \\sigma_i^2 \\text{ subject to } \\sum a_i = 1.\n$$\n\n\nThis problem is similar now to the last one, save the sum to minimize includes the sigmas. Set $L = \\sum a_i^2 \\sigma_i^2  + \\lambda\\sum a_i - 1$\n\n\nTaking $\\partial/\\partial{a_i}$ gives equations $2a_i\\sigma_i^2 + \\lambda = 0$, $a_i = -\\lambda/(2\\sigma_i^2) = c/\\sigma_i^2$. The constraint implies $c = 1/\\sum(1/\\sigma_i)^2$. So variables with *more* variance, get smaller weights.\n\n\nFor the special case of a common variance, $\\sigma_i=\\sigma$, the above simplifies to $a_i = 1/n$ and the estimator is $\\sum X_i/n$, the familiar sample mean, $\\bar{X}$.\n\n\n## Questions\n\n\n###### Question\n\n\nThe following plots a surface defined by a (hidden) function $F: R^2 \\rightarrow R^3$:\n\n::: {.cell execution_count=33}\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\n𝑭 (generic function with 1 method)\n```\n:::\n:::\n\n\n::: {.cell hold='true' execution_count=34}\n``` {.julia .cell-code}\nus, vs = range(0, 1, length=25), range(0, 2pi, length=25)\nxs, ys, zs = unzip(𝑭.(us, vs'))\nsurface(xs, ys, zs)\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n![](vector_fields_files/figure-html/cell-35-output-1.svg){}\n:::\n:::\n\n\nIs this the surface generated by $F(u,v) = \\langle u\\cos(v), u\\sin(v), 2v\\rangle$? This function's surface is termed a helicoid.\n\n::: {.cell hold='true' execution_count=35}\n\n::: {.cell-output .cell-output-display execution_count=34}\n```{=html}\n<form class=\"mx-2 my-3 mw-100\" name='WeaveQuestion' data-id='9835898825721379564' data-controltype=''>\n  <div class='form-group '>\n    <div class='controls'>\n      <div class=\"form\" id=\"controls_9835898825721379564\">\n        <div style=\"padding-top: 5px\">\n    <div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_9835898825721379564_1\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_9835898825721379564\"\n              id=\"radio_9835898825721379564_1\" value=\"1\">\n      </input>\n      <span class=\"label-body px-1\">\n        Yes\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_9835898825721379564_2\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_9835898825721379564\"\n              id=\"radio_9835898825721379564_2\" value=\"2\">\n      </input>\n      <span class=\"label-body px-1\">\n        No\n      </span>\n    </label>\n</div>\n\n    \n        </div>\n      </div>\n      <div id='9835898825721379564_message' style=\"padding-bottom: 15px\"></div>\n    </div>\n  </div>\n</form>\n\n<script text='text/javascript'>\ndocument.querySelectorAll('input[name=\"radio_9835898825721379564\"]').forEach(function(rb) {\nrb.addEventListener(\"change\", function() {\n    var correct = rb.value == 1;\n    var msgBox = document.getElementById('9835898825721379564_message');\n      if(correct) {\n    msgBox.innerHTML = \"<div class='pluto-output admonition note alert alert-success'><span> 👍&nbsp; Correct </span></div>\";\n    var explanation = document.getElementById(\"explanation_9835898825721379564\")\n    if (explanation != null) {\n       explanation.style.display = \"none\";\n    }\n  } else {\n    msgBox.innerHTML = \"<div class='pluto-output admonition alert alert-danger'><span>👎&nbsp; Incorrect </span></div>\";\n    var explanation = document.getElementById(\"explanation_9835898825721379564\")\n    if (explanation != null) {\n       explanation.style.display = \"block\";\n    }\n  }\n\n})});\n\n</script>\n```\n:::\n:::\n\n\n###### Question\n\n\nThe following plots a surface defined by a (hidden) function $F: R^2 \\rightarrow R^3$ of the form $F(u,v) = \\langle r(u)\\cos(v), r(u)\\sin(v), u\\rangle$\n\n::: {.cell execution_count=36}\n\n::: {.cell-output .cell-output-display execution_count=35}\n```\nℱ (generic function with 1 method)\n```\n:::\n:::\n\n\n::: {.cell hold='true' execution_count=37}\n``` {.julia .cell-code}\nus, vs = range(-1, 1, length=25), range(0, 2pi, length=25)\nxs, ys, zs = unzip(ℱ.(us, vs'))\nsurface(xs, ys, zs)\n```\n\n::: {.cell-output .cell-output-display execution_count=36}\n![](vector_fields_files/figure-html/cell-38-output-1.svg){}\n:::\n:::\n\n\nIs this the surface generated by $r(u) = 1+u^2$? This form of a function is for a surface of revolution about the $z$ axis.\n\n::: {.cell hold='true' execution_count=38}\n\n::: {.cell-output .cell-output-display execution_count=37}\n```{=html}\n<form class=\"mx-2 my-3 mw-100\" name='WeaveQuestion' data-id='14008180780358663510' data-controltype=''>\n  <div class='form-group '>\n    <div class='controls'>\n      <div class=\"form\" id=\"controls_14008180780358663510\">\n        <div style=\"padding-top: 5px\">\n    <div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_14008180780358663510_1\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_14008180780358663510\"\n              id=\"radio_14008180780358663510_1\" value=\"1\">\n      </input>\n      <span class=\"label-body px-1\">\n        Yes\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_14008180780358663510_2\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_14008180780358663510\"\n              id=\"radio_14008180780358663510_2\" value=\"2\">\n      </input>\n      <span class=\"label-body px-1\">\n        No\n      </span>\n    </label>\n</div>\n\n    \n        </div>\n      </div>\n      <div id='14008180780358663510_message' style=\"padding-bottom: 15px\"></div>\n    </div>\n  </div>\n</form>\n\n<script text='text/javascript'>\ndocument.querySelectorAll('input[name=\"radio_14008180780358663510\"]').forEach(function(rb) {\nrb.addEventListener(\"change\", function() {\n    var correct = rb.value == 1;\n    var msgBox = document.getElementById('14008180780358663510_message');\n      if(correct) {\n    msgBox.innerHTML = \"<div class='pluto-output admonition note alert alert-success'><span> 👍&nbsp; Correct </span></div>\";\n    var explanation = document.getElementById(\"explanation_14008180780358663510\")\n    if (explanation != null) {\n       explanation.style.display = \"none\";\n    }\n  } else {\n    msgBox.innerHTML = \"<div class='pluto-output admonition alert alert-danger'><span>👎&nbsp; Incorrect </span></div>\";\n    var explanation = document.getElementById(\"explanation_14008180780358663510\")\n    if (explanation != null) {\n       explanation.style.display = \"block\";\n    }\n  }\n\n})});\n\n</script>\n```\n:::\n:::\n\n\n###### Question\n\n\nThe transformation $F(x, y) = \\langle 2x + 3y + 1, 4x + y + 2\\rangle$ is an example of an affine transformation. Is this the *Jacobian* of $F$\n\n\n\n$$\nJ = \\left[\n\\begin{array}{}\n2 & 4\\\\\n3 & 1\n\\end{array}\n\\right].\n$$\n\n::: {.cell hold='true' execution_count=39}\n\n::: {.cell-output .cell-output-display execution_count=38}\n```{=html}\n<form class=\"mx-2 my-3 mw-100\" name='WeaveQuestion' data-id='16765359538051888652' data-controltype=''>\n  <div class='form-group '>\n    <div class='controls'>\n      <div class=\"form\" id=\"controls_16765359538051888652\">\n        <div style=\"padding-top: 5px\">\n    <div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_16765359538051888652_1\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_16765359538051888652\"\n              id=\"radio_16765359538051888652_1\" value=\"1\">\n      </input>\n      <span class=\"label-body px-1\">\n        Yes\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_16765359538051888652_2\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_16765359538051888652\"\n              id=\"radio_16765359538051888652_2\" value=\"2\">\n      </input>\n      <span class=\"label-body px-1\">\n        No, it is the transpose\n      </span>\n    </label>\n</div>\n\n    \n        </div>\n      </div>\n      <div id='16765359538051888652_message' style=\"padding-bottom: 15px\"></div>\n    </div>\n  </div>\n</form>\n\n<script text='text/javascript'>\ndocument.querySelectorAll('input[name=\"radio_16765359538051888652\"]').forEach(function(rb) {\nrb.addEventListener(\"change\", function() {\n    var correct = rb.value == 2;\n    var msgBox = document.getElementById('16765359538051888652_message');\n      if(correct) {\n    msgBox.innerHTML = \"<div class='pluto-output admonition note alert alert-success'><span> 👍&nbsp; Correct </span></div>\";\n    var explanation = document.getElementById(\"explanation_16765359538051888652\")\n    if (explanation != null) {\n       explanation.style.display = \"none\";\n    }\n  } else {\n    msgBox.innerHTML = \"<div class='pluto-output admonition alert alert-danger'><span>👎&nbsp; Incorrect </span></div>\";\n    var explanation = document.getElementById(\"explanation_16765359538051888652\")\n    if (explanation != null) {\n       explanation.style.display = \"block\";\n    }\n  }\n\n})});\n\n</script>\n```\n:::\n:::\n\n\n###### Question\n\n\nDoes the transformation $F(u,v) = \\langle u^2 - v^2, u^2 + v^2 \\rangle$ have Jacobian\n\n\n\n$$\nJ = \\left[\n\\begin{array}{}\n2u & -2v\\\\\n2u & 2v\n\\end{array}\n\\right]?\n$$\n\n::: {.cell hold='true' execution_count=40}\n\n::: {.cell-output .cell-output-display execution_count=39}\n```{=html}\n<form class=\"mx-2 my-3 mw-100\" name='WeaveQuestion' data-id='3897003820059249127' data-controltype=''>\n  <div class='form-group '>\n    <div class='controls'>\n      <div class=\"form\" id=\"controls_3897003820059249127\">\n        <div style=\"padding-top: 5px\">\n    <div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_3897003820059249127_1\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_3897003820059249127\"\n              id=\"radio_3897003820059249127_1\" value=\"1\">\n      </input>\n      <span class=\"label-body px-1\">\n        Yes\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_3897003820059249127_2\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_3897003820059249127\"\n              id=\"radio_3897003820059249127_2\" value=\"2\">\n      </input>\n      <span class=\"label-body px-1\">\n        No, it is the transpose\n      </span>\n    </label>\n</div>\n\n    \n        </div>\n      </div>\n      <div id='3897003820059249127_message' style=\"padding-bottom: 15px\"></div>\n    </div>\n  </div>\n</form>\n\n<script text='text/javascript'>\ndocument.querySelectorAll('input[name=\"radio_3897003820059249127\"]').forEach(function(rb) {\nrb.addEventListener(\"change\", function() {\n    var correct = rb.value == 1;\n    var msgBox = document.getElementById('3897003820059249127_message');\n      if(correct) {\n    msgBox.innerHTML = \"<div class='pluto-output admonition note alert alert-success'><span> 👍&nbsp; Correct </span></div>\";\n    var explanation = document.getElementById(\"explanation_3897003820059249127\")\n    if (explanation != null) {\n       explanation.style.display = \"none\";\n    }\n  } else {\n    msgBox.innerHTML = \"<div class='pluto-output admonition alert alert-danger'><span>👎&nbsp; Incorrect </span></div>\";\n    var explanation = document.getElementById(\"explanation_3897003820059249127\")\n    if (explanation != null) {\n       explanation.style.display = \"block\";\n    }\n  }\n\n})});\n\n</script>\n```\n:::\n:::\n\n\n###### Question\n\n\nFix constants $\\lambda_0$ and $\\phi_0$ and define a transformation\n\n\n\n$$\nF(\\lambda, \\phi) = \\langle \\cos(\\phi)\\sin(\\lambda - \\lambda_0),\n\\cos(\\phi_0)\\sin(\\phi) - \\sin(\\phi_0)\\cos(\\phi)\\cos(\\lambda - \\lambda_0) \\rangle\n$$\n\n\nWhat does the following `SymPy` code compute?\n\n::: {.cell hold='true' execution_count=41}\n``` {.julia .cell-code}\n@syms lambda lambda_0 phi phi_0\nF(lambda,phi) = [cos(phi)*sin(lambda-lambda_0), cos(phi_0)*sin(phi) - sin(phi_0)*cos(phi)*cos(lambda-lambda_0)]\n\nout = [diff.(F(lambda, phi), lambda) diff.(F(lambda, phi), phi)]\ndet(out) |> simplify\n```\n\n::: {.cell-output .cell-output-display execution_count=40}\n```{=html}\n<span class=\"math-left-align\" style=\"padding-left: 4px; width:0; float:left;\"> \n\\[\n\\left(\\sin{\\left(\\phi \\right)} \\sin{\\left(\\phi_{0} \\right)} + \\cos{\\left(\\phi \\right)} \\cos{\\left(\\phi_{0} \\right)} \\cos{\\left(\\lambda - \\lambda_{0} \\right)}\\right) \\cos{\\left(\\phi \\right)}\n\\]\n</span>\n```\n:::\n:::\n\n\n::: {.cell hold='true' execution_count=42}\n\n::: {.cell-output .cell-output-display execution_count=41}\n```{=html}\n<form class=\"mx-2 my-3 mw-100\" name='WeaveQuestion' data-id='13635260257390893117' data-controltype=''>\n  <div class='form-group '>\n    <div class='controls'>\n      <div class=\"form\" id=\"controls_13635260257390893117\">\n        <div style=\"padding-top: 5px\">\n    <div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_13635260257390893117_1\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_13635260257390893117\"\n              id=\"radio_13635260257390893117_1\" value=\"1\">\n      </input>\n      <span class=\"label-body px-1\">\n        The determinant of the Jacobian.\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_13635260257390893117_2\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_13635260257390893117\"\n              id=\"radio_13635260257390893117_2\" value=\"2\">\n      </input>\n      <span class=\"label-body px-1\">\n        The determinant of the Hessian.\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_13635260257390893117_3\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_13635260257390893117\"\n              id=\"radio_13635260257390893117_3\" value=\"3\">\n      </input>\n      <span class=\"label-body px-1\">\n        The determinant of the gradient.\n      </span>\n    </label>\n</div>\n\n    \n        </div>\n      </div>\n      <div id='13635260257390893117_message' style=\"padding-bottom: 15px\"></div>\n    </div>\n  </div>\n</form>\n\n<script text='text/javascript'>\ndocument.querySelectorAll('input[name=\"radio_13635260257390893117\"]').forEach(function(rb) {\nrb.addEventListener(\"change\", function() {\n    var correct = rb.value == 1;\n    var msgBox = document.getElementById('13635260257390893117_message');\n      if(correct) {\n    msgBox.innerHTML = \"<div class='pluto-output admonition note alert alert-success'><span> 👍&nbsp; Correct </span></div>\";\n    var explanation = document.getElementById(\"explanation_13635260257390893117\")\n    if (explanation != null) {\n       explanation.style.display = \"none\";\n    }\n  } else {\n    msgBox.innerHTML = \"<div class='pluto-output admonition alert alert-danger'><span>👎&nbsp; Incorrect </span></div>\";\n    var explanation = document.getElementById(\"explanation_13635260257390893117\")\n    if (explanation != null) {\n       explanation.style.display = \"block\";\n    }\n  }\n\n})});\n\n</script>\n```\n:::\n:::\n\n\nWhat would be a more direct method:\n\n::: {.cell hold='true' execution_count=43}\n\n::: {.cell-output .cell-output-display execution_count=42}\n```{=html}\n<form class=\"mx-2 my-3 mw-100\" name='WeaveQuestion' data-id='64851843036617893' data-controltype=''>\n  <div class='form-group '>\n    <div class='controls'>\n      <div class=\"form\" id=\"controls_64851843036617893\">\n        <div style=\"padding-top: 5px\">\n    <div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_64851843036617893_1\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_64851843036617893\"\n              id=\"radio_64851843036617893_1\" value=\"1\">\n      </input>\n      <span class=\"label-body px-1\">\n        <code>det&#40;F&#40;lambda, phi&#41;.jacobian&#40;&#91;lambda, phi&#93;&#41;&#41;</code>\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_64851843036617893_2\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_64851843036617893\"\n              id=\"radio_64851843036617893_2\" value=\"2\">\n      </input>\n      <span class=\"label-body px-1\">\n        <code>det&#40;hessian&#40;F&#40;lambda, phi&#41;, &#91;lambda, phi&#93;&#41;&#41;</code>\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_64851843036617893_3\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_64851843036617893\"\n              id=\"radio_64851843036617893_3\" value=\"3\">\n      </input>\n      <span class=\"label-body px-1\">\n        <code>det&#40;gradient&#40;F&#40;lambda, phi&#41;, &#91;lambda, phi&#93;&#41;&#41;</code>\n      </span>\n    </label>\n</div>\n\n    \n        </div>\n      </div>\n      <div id='64851843036617893_message' style=\"padding-bottom: 15px\"></div>\n    </div>\n  </div>\n</form>\n\n<script text='text/javascript'>\ndocument.querySelectorAll('input[name=\"radio_64851843036617893\"]').forEach(function(rb) {\nrb.addEventListener(\"change\", function() {\n    var correct = rb.value == 1;\n    var msgBox = document.getElementById('64851843036617893_message');\n      if(correct) {\n    msgBox.innerHTML = \"<div class='pluto-output admonition note alert alert-success'><span> 👍&nbsp; Correct </span></div>\";\n    var explanation = document.getElementById(\"explanation_64851843036617893\")\n    if (explanation != null) {\n       explanation.style.display = \"none\";\n    }\n  } else {\n    msgBox.innerHTML = \"<div class='pluto-output admonition alert alert-danger'><span>👎&nbsp; Incorrect </span></div>\";\n    var explanation = document.getElementById(\"explanation_64851843036617893\")\n    if (explanation != null) {\n       explanation.style.display = \"block\";\n    }\n  }\n\n})});\n\n</script>\n```\n:::\n:::\n\n\n###### Question\n\n\nLet $z\\sin(z) = x^3y^2 + z$. Compute $\\partial{z}/\\partial{x}$ implicitly.\n\n::: {.cell hold='true' execution_count=44}\n\n::: {.cell-output .cell-output-display execution_count=43}\n```{=html}\n<form class=\"mx-2 my-3 mw-100\" name='WeaveQuestion' data-id='5965065372842851920' data-controltype=''>\n  <div class='form-group '>\n    <div class='controls'>\n      <div class=\"form\" id=\"controls_5965065372842851920\">\n        <div style=\"padding-top: 5px\">\n    <div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_5965065372842851920_1\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_5965065372842851920\"\n              id=\"radio_5965065372842851920_1\" value=\"1\">\n      </input>\n      <span class=\"label-body px-1\">\n        \\(3x^2y^2/(z\\cos(z) + \\sin(z) + 1)\\)\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_5965065372842851920_2\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_5965065372842851920\"\n              id=\"radio_5965065372842851920_2\" value=\"2\">\n      </input>\n      <span class=\"label-body px-1\">\n        \\(2x^3y/ (z\\cos(z) + \\sin(z) + 1)\\)\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_5965065372842851920_3\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_5965065372842851920\"\n              id=\"radio_5965065372842851920_3\" value=\"3\">\n      </input>\n      <span class=\"label-body px-1\">\n        \\(3x^2y^2\\)\n      </span>\n    </label>\n</div>\n\n    \n        </div>\n      </div>\n      <div id='5965065372842851920_message' style=\"padding-bottom: 15px\"></div>\n    </div>\n  </div>\n</form>\n\n<script text='text/javascript'>\ndocument.querySelectorAll('input[name=\"radio_5965065372842851920\"]').forEach(function(rb) {\nrb.addEventListener(\"change\", function() {\n    var correct = rb.value == 1;\n    var msgBox = document.getElementById('5965065372842851920_message');\n      if(correct) {\n    msgBox.innerHTML = \"<div class='pluto-output admonition note alert alert-success'><span> 👍&nbsp; Correct </span></div>\";\n    var explanation = document.getElementById(\"explanation_5965065372842851920\")\n    if (explanation != null) {\n       explanation.style.display = \"none\";\n    }\n  } else {\n    msgBox.innerHTML = \"<div class='pluto-output admonition alert alert-danger'><span>👎&nbsp; Incorrect </span></div>\";\n    var explanation = document.getElementById(\"explanation_5965065372842851920\")\n    if (explanation != null) {\n       explanation.style.display = \"block\";\n    }\n  }\n\n})});\n\n</script>\n```\n:::\n:::\n\n\n###### Question\n\n\nLet $x^4 + y^4 + z^4 + x^2y^2z^2 = 1$. Compute $\\partial{z}/\\partial{y}$ implicitly.\n\n::: {.cell hold='true' execution_count=45}\n\n::: {.cell-output .cell-output-display execution_count=44}\n```{=html}\n<form class=\"mx-2 my-3 mw-100\" name='WeaveQuestion' data-id='14230596131957479142' data-controltype=''>\n  <div class='form-group '>\n    <div class='controls'>\n      <div class=\"form\" id=\"controls_14230596131957479142\">\n        <div style=\"padding-top: 5px\">\n    <div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_14230596131957479142_1\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_14230596131957479142\"\n              id=\"radio_14230596131957479142_1\" value=\"1\">\n      </input>\n      <span class=\"label-body px-1\">\n        \\(\\frac{x \\left(2 x^{2} - z^{2}{\\left (x,y \\right )}\\right)}{\\left(x^{2} - 2 z^{2}{\\left (x,y \\right )}\\right) z{\\left (x,y \\right )}}\\)\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_14230596131957479142_2\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_14230596131957479142\"\n              id=\"radio_14230596131957479142_2\" value=\"2\">\n      </input>\n      <span class=\"label-body px-1\">\n        \\(\\frac{x \\left(2 x^{2} - y^{2} z^{2}{\\left (x,y \\right )}\\right)}{\\left(x^{2} y^{2} - 2 z^{2}{\\left (x,y \\right )}\\right) z{\\left (x,y \\right )}}\\)\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_14230596131957479142_3\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_14230596131957479142\"\n              id=\"radio_14230596131957479142_3\" value=\"3\">\n      </input>\n      <span class=\"label-body px-1\">\n        \\(\\frac{y \\left(- x^{2} z^{2}{\\left (x,y \\right )} + 2 y^{2}\\right)}{\\left(x^{2} y^{2} - 2 z^{2}{\\left (x,y \\right )}\\right) z{\\left (x,y \\right )}}\\)\n      </span>\n    </label>\n</div>\n\n    \n        </div>\n      </div>\n      <div id='14230596131957479142_message' style=\"padding-bottom: 15px\"></div>\n    </div>\n  </div>\n</form>\n\n<script text='text/javascript'>\ndocument.querySelectorAll('input[name=\"radio_14230596131957479142\"]').forEach(function(rb) {\nrb.addEventListener(\"change\", function() {\n    var correct = rb.value == 3;\n    var msgBox = document.getElementById('14230596131957479142_message');\n      if(correct) {\n    msgBox.innerHTML = \"<div class='pluto-output admonition note alert alert-success'><span> 👍&nbsp; Correct </span></div>\";\n    var explanation = document.getElementById(\"explanation_14230596131957479142\")\n    if (explanation != null) {\n       explanation.style.display = \"none\";\n    }\n  } else {\n    msgBox.innerHTML = \"<div class='pluto-output admonition alert alert-danger'><span>👎&nbsp; Incorrect </span></div>\";\n    var explanation = document.getElementById(\"explanation_14230596131957479142\")\n    if (explanation != null) {\n       explanation.style.display = \"block\";\n    }\n  }\n\n})});\n\n</script>\n```\n:::\n:::\n\n\n###### Question\n\n\nConsider the vector field $R:R^2 \\rightarrow R^2$ defined by $R(x,y) = \\langle x, y\\rangle$ and the vector field $S:R^2\\rightarrow R^2$ defined by $S(x,y) = \\langle -y, x\\rangle$. Let $r = \\|R\\| = \\sqrt{x^2 + y^2}$. $R$ is a radial field, $S$ a spin field.\n\n\nWhat is $\\nabla{r}$?\n\n::: {.cell hold='true' execution_count=46}\n\n::: {.cell-output .cell-output-display execution_count=45}\n```{=html}\n<form class=\"mx-2 my-3 mw-100\" name='WeaveQuestion' data-id='12071098944131314902' data-controltype=''>\n  <div class='form-group '>\n    <div class='controls'>\n      <div class=\"form\" id=\"controls_12071098944131314902\">\n        <div style=\"padding-top: 5px\">\n    <div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_12071098944131314902_1\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_12071098944131314902\"\n              id=\"radio_12071098944131314902_1\" value=\"1\">\n      </input>\n      <span class=\"label-body px-1\">\n        \\(R\\)\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_12071098944131314902_2\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_12071098944131314902\"\n              id=\"radio_12071098944131314902_2\" value=\"2\">\n      </input>\n      <span class=\"label-body px-1\">\n        \\(R/r\\)\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_12071098944131314902_3\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_12071098944131314902\"\n              id=\"radio_12071098944131314902_3\" value=\"3\">\n      </input>\n      <span class=\"label-body px-1\">\n        \\(S/r\\)\n      </span>\n    </label>\n</div>\n\n    \n        </div>\n      </div>\n      <div id='12071098944131314902_message' style=\"padding-bottom: 15px\"></div>\n    </div>\n  </div>\n</form>\n\n<script text='text/javascript'>\ndocument.querySelectorAll('input[name=\"radio_12071098944131314902\"]').forEach(function(rb) {\nrb.addEventListener(\"change\", function() {\n    var correct = rb.value == 2;\n    var msgBox = document.getElementById('12071098944131314902_message');\n      if(correct) {\n    msgBox.innerHTML = \"<div class='pluto-output admonition note alert alert-success'><span> 👍&nbsp; Correct </span></div>\";\n    var explanation = document.getElementById(\"explanation_12071098944131314902\")\n    if (explanation != null) {\n       explanation.style.display = \"none\";\n    }\n  } else {\n    msgBox.innerHTML = \"<div class='pluto-output admonition alert alert-danger'><span>👎&nbsp; Incorrect </span></div>\";\n    var explanation = document.getElementById(\"explanation_12071098944131314902\")\n    if (explanation != null) {\n       explanation.style.display = \"block\";\n    }\n  }\n\n})});\n\n</script>\n```\n:::\n:::\n\n\nLet $\\phi = r^k$. What is $\\nabla{\\phi}$?\n\n::: {.cell hold='true' execution_count=47}\n\n::: {.cell-output .cell-output-display execution_count=46}\n```{=html}\n<form class=\"mx-2 my-3 mw-100\" name='WeaveQuestion' data-id='2381298859491462944' data-controltype=''>\n  <div class='form-group '>\n    <div class='controls'>\n      <div class=\"form\" id=\"controls_2381298859491462944\">\n        <div style=\"padding-top: 5px\">\n    <div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_2381298859491462944_1\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_2381298859491462944\"\n              id=\"radio_2381298859491462944_1\" value=\"1\">\n      </input>\n      <span class=\"label-body px-1\">\n        \\(k r^{k-2} S\\)\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_2381298859491462944_2\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_2381298859491462944\"\n              id=\"radio_2381298859491462944_2\" value=\"2\">\n      </input>\n      <span class=\"label-body px-1\">\n        \\(kr^k R\\)\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_2381298859491462944_3\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_2381298859491462944\"\n              id=\"radio_2381298859491462944_3\" value=\"3\">\n      </input>\n      <span class=\"label-body px-1\">\n        \\(k r^{k-2} R\\)\n      </span>\n    </label>\n</div>\n\n    \n        </div>\n      </div>\n      <div id='2381298859491462944_message' style=\"padding-bottom: 15px\"></div>\n    </div>\n  </div>\n</form>\n\n<script text='text/javascript'>\ndocument.querySelectorAll('input[name=\"radio_2381298859491462944\"]').forEach(function(rb) {\nrb.addEventListener(\"change\", function() {\n    var correct = rb.value == 3;\n    var msgBox = document.getElementById('2381298859491462944_message');\n      if(correct) {\n    msgBox.innerHTML = \"<div class='pluto-output admonition note alert alert-success'><span> 👍&nbsp; Correct </span></div>\";\n    var explanation = document.getElementById(\"explanation_2381298859491462944\")\n    if (explanation != null) {\n       explanation.style.display = \"none\";\n    }\n  } else {\n    msgBox.innerHTML = \"<div class='pluto-output admonition alert alert-danger'><span>👎&nbsp; Incorrect </span></div>\";\n    var explanation = document.getElementById(\"explanation_2381298859491462944\")\n    if (explanation != null) {\n       explanation.style.display = \"block\";\n    }\n  }\n\n})});\n\n</script>\n```\n:::\n:::\n\n\nBased on your last answer, are all radial fields $R/r^n$, $n\\geq 0$ gradients of scalar functions?\n\n::: {.cell hold='true' execution_count=48}\n\n::: {.cell-output .cell-output-display execution_count=47}\n```{=html}\n<form class=\"mx-2 my-3 mw-100\" name='WeaveQuestion' data-id='16202971200098607033' data-controltype=''>\n  <div class='form-group '>\n    <div class='controls'>\n      <div class=\"form\" id=\"controls_16202971200098607033\">\n        <div style=\"padding-top: 5px\">\n    <div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_16202971200098607033_1\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_16202971200098607033\"\n              id=\"radio_16202971200098607033_1\" value=\"1\">\n      </input>\n      <span class=\"label-body px-1\">\n        Yes\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_16202971200098607033_2\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_16202971200098607033\"\n              id=\"radio_16202971200098607033_2\" value=\"2\">\n      </input>\n      <span class=\"label-body px-1\">\n        No\n      </span>\n    </label>\n</div>\n\n    \n        </div>\n      </div>\n      <div id='16202971200098607033_message' style=\"padding-bottom: 15px\"></div>\n    </div>\n  </div>\n</form>\n\n<script text='text/javascript'>\ndocument.querySelectorAll('input[name=\"radio_16202971200098607033\"]').forEach(function(rb) {\nrb.addEventListener(\"change\", function() {\n    var correct = rb.value == 1;\n    var msgBox = document.getElementById('16202971200098607033_message');\n      if(correct) {\n    msgBox.innerHTML = \"<div class='pluto-output admonition note alert alert-success'><span> 👍&nbsp; Correct </span></div>\";\n    var explanation = document.getElementById(\"explanation_16202971200098607033\")\n    if (explanation != null) {\n       explanation.style.display = \"none\";\n    }\n  } else {\n    msgBox.innerHTML = \"<div class='pluto-output admonition alert alert-danger'><span>👎&nbsp; Incorrect </span></div>\";\n    var explanation = document.getElementById(\"explanation_16202971200098607033\")\n    if (explanation != null) {\n       explanation.style.display = \"block\";\n    }\n  }\n\n})});\n\n</script>\n```\n:::\n:::\n\n\nLet $\\phi = \\tan^{-1}(y/x)$. What is $\\nabla{\\phi}$?\n\n::: {.cell hold='true' execution_count=49}\n\n::: {.cell-output .cell-output-display execution_count=48}\n```{=html}\n<form class=\"mx-2 my-3 mw-100\" name='WeaveQuestion' data-id='609659548042096721' data-controltype=''>\n  <div class='form-group '>\n    <div class='controls'>\n      <div class=\"form\" id=\"controls_609659548042096721\">\n        <div style=\"padding-top: 5px\">\n    <div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_609659548042096721_1\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_609659548042096721\"\n              id=\"radio_609659548042096721_1\" value=\"1\">\n      </input>\n      <span class=\"label-body px-1\">\n        \\(S/r\\)\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_609659548042096721_2\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_609659548042096721\"\n              id=\"radio_609659548042096721_2\" value=\"2\">\n      </input>\n      <span class=\"label-body px-1\">\n        \\(S\\)\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_609659548042096721_3\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_609659548042096721\"\n              id=\"radio_609659548042096721_3\" value=\"3\">\n      </input>\n      <span class=\"label-body px-1\">\n        \\(S/r^2\\)\n      </span>\n    </label>\n</div>\n\n    \n        </div>\n      </div>\n      <div id='609659548042096721_message' style=\"padding-bottom: 15px\"></div>\n    </div>\n  </div>\n</form>\n\n<script text='text/javascript'>\ndocument.querySelectorAll('input[name=\"radio_609659548042096721\"]').forEach(function(rb) {\nrb.addEventListener(\"change\", function() {\n    var correct = rb.value == 3;\n    var msgBox = document.getElementById('609659548042096721_message');\n      if(correct) {\n    msgBox.innerHTML = \"<div class='pluto-output admonition note alert alert-success'><span> 👍&nbsp; Correct </span></div>\";\n    var explanation = document.getElementById(\"explanation_609659548042096721\")\n    if (explanation != null) {\n       explanation.style.display = \"none\";\n    }\n  } else {\n    msgBox.innerHTML = \"<div class='pluto-output admonition alert alert-danger'><span>👎&nbsp; Incorrect </span></div>\";\n    var explanation = document.getElementById(\"explanation_609659548042096721\")\n    if (explanation != null) {\n       explanation.style.display = \"block\";\n    }\n  }\n\n})});\n\n</script>\n```\n:::\n:::\n\n\nExpress $S/r^n = \\langle F_x, F_y\\rangle$. For which $n$ is $\\partial{F_y}/\\partial{x} - \\partial{F_x}/\\partial{y} = 0$?\n\n::: {.cell hold='true' execution_count=50}\n\n::: {.cell-output .cell-output-display execution_count=49}\n```{=html}\n<form class=\"mx-2 my-3 mw-100\" name='WeaveQuestion' data-id='17174041235273905610' data-controltype=''>\n  <div class='form-group '>\n    <div class='controls'>\n      <div class=\"form\" id=\"controls_17174041235273905610\">\n        <div style=\"padding-top: 5px\">\n    <div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_17174041235273905610_1\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_17174041235273905610\"\n              id=\"radio_17174041235273905610_1\" value=\"1\">\n      </input>\n      <span class=\"label-body px-1\">\n        As the left-hand side becomes \\((-n+2)r^{-n}\\), only \\(n=2\\).\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_17174041235273905610_2\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_17174041235273905610\"\n              id=\"radio_17174041235273905610_2\" value=\"2\">\n      </input>\n      <span class=\"label-body px-1\">\n        All \\(n \\geq 0\\)\n      </span>\n    </label>\n</div>\n<div class=\"form-check\">\n    <label class=\"form-check-label\" for=\"radio_17174041235273905610_3\">\n      <input class=\"form-check-input\" type=\"radio\" name=\"radio_17174041235273905610\"\n              id=\"radio_17174041235273905610_3\" value=\"3\">\n      </input>\n      <span class=\"label-body px-1\">\n        No values of \\(n\\)\n      </span>\n    </label>\n</div>\n\n    \n        </div>\n      </div>\n      <div id='17174041235273905610_message' style=\"padding-bottom: 15px\"></div>\n    </div>\n  </div>\n</form>\n\n<script text='text/javascript'>\ndocument.querySelectorAll('input[name=\"radio_17174041235273905610\"]').forEach(function(rb) {\nrb.addEventListener(\"change\", function() {\n    var correct = rb.value == 1;\n    var msgBox = document.getElementById('17174041235273905610_message');\n      if(correct) {\n    msgBox.innerHTML = \"<div class='pluto-output admonition note alert alert-success'><span> 👍&nbsp; Correct </span></div>\";\n    var explanation = document.getElementById(\"explanation_17174041235273905610\")\n    if (explanation != null) {\n       explanation.style.display = \"none\";\n    }\n  } else {\n    msgBox.innerHTML = \"<div class='pluto-output admonition alert alert-danger'><span>👎&nbsp; Incorrect </span></div>\";\n    var explanation = document.getElementById(\"explanation_17174041235273905610\")\n    if (explanation != null) {\n       explanation.style.display = \"block\";\n    }\n  }\n\n})});\n\n</script>\n```\n:::\n:::\n\n\n(The latter is of interest, as only when the expression is $0$ will the vector field be the gradient of a scalar function.)\n\n",
    "supporting": [
      "vector_fields_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}