{
  "hash": "e355d4e9229de92d236ee4055661f241",
  "result": {
    "markdown": "# 2D and 3D plots in Julia with Plots\n\n\n\nThis section uses these add-on packages:\n\n``` {.julia .cell-code}\nusing CalculusWithJulia\nusing Plots\nimport Contour: contours, levels, level, lines, coordinates\nusing LinearAlgebra\nusing ForwardDiff\n```\n\n\n\n\n---\n\n\nThis covers plotting the typical 2D and 3D plots in Julia with the `Plots` package.\n\n\nWe will make use of some helper functions that will simplify plotting provided by the `CalculusWithJulia` package. As well, we will need to manipulate contours directly, so pull in the `Contours` package, using `import` to avoid name collisions and explicitly listing the methods we will use.\n\n\n## Parametrically described curves in space\n\n\nLet $r(t)$ be a vector-valued function with values in $R^d$, $d$ being $2$ or $3$. A familiar example is the equation for a line that travels in the direction of $\\vec{v}$ and goes through the point $P$: $r(t) = P + t \\cdot \\vec{v}$. A *parametric plot* over $[a,b]$ is the collection of all points $r(t)$ for $a \\leq t \\leq b$.\n\n\nIn `Plots`, parameterized curves can be plotted through two interfaces, here illustrated for $d=2$: `plot(f1, f2, a, b)` or `plot(xs, ys)`. The former is convenient for some cases, but typically we will have a function `r(t)` which is vector-valued, as opposed to a vector of functions. As such, we only discuss the latter.\n\n\nAn example helps illustrate. Suppose $r(t) = \\langle \\sin(t), 2\\cos(t) \\rangle$ and the goal is to plot the full ellipse by plotting over $0 \\leq t \\leq 2\\pi$. As with plotting of curves, the goal would be to take many points between `a` and `b` and from there generate the $x$ values and $y$ values.\n\n\nLet's see this with 5 points, the first and last being identical due to the curve:\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nr₂(t) = [sin(t), 2cos(t)]\nts = range(0, stop=2pi, length=5)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n0.0:1.5707963267948966:6.283185307179586\n```\n:::\n:::\n\n\nThen we can create the $5$ points easily through broadcasting:\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\nvs = r₂.(ts)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n5-element Vector{Vector{Float64}}:\n [0.0, 2.0]\n [1.0, 1.2246467991473532e-16]\n [1.2246467991473532e-16, -2.0]\n [-1.0, -3.6739403974420594e-16]\n [-2.4492935982947064e-16, 2.0]\n```\n:::\n:::\n\n\nThis returns a vector of points (stored as vectors). The plotting function wants two collections: the set of $x$ values for the points and the set of $y$ values. The data needs to be generated differently or reshaped. The function `unzip` above takes data in this style and returns the desired format, returning a tuple with the $x$ values and $y$ values pulled out:\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\nunzip(vs)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n([0.0, 1.0, 1.2246467991473532e-16, -1.0, -2.4492935982947064e-16], [2.0, 1.2246467991473532e-16, -2.0, -3.6739403974420594e-16, 2.0])\n```\n:::\n:::\n\n\nTo plot this, we \"splat\" the tuple so that `plot` gets the arguments separately:\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\nplot(unzip(vs)...)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n![](plots_plotting_files/figure-html/cell-8-output-1.svg){}\n:::\n:::\n\n\nThis  basic plot is lacking, of course, as there are not enough points. Using more initially is a remedy.\n\n::: {.cell hold='true' execution_count=8}\n``` {.julia .cell-code}\nts = range(0, 2pi, length=100)\nplot(unzip(r₂.(ts))...)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n![](plots_plotting_files/figure-html/cell-9-output-1.svg){}\n:::\n:::\n\n\nAs a convenience, `CalculusWithJulia` provides `plot_parametric` to produce this plot. The interval is specified with the  `a..b` notation of `IntervalSets` (which is available when the `CalculusWithJulia` package is loaded), the points to plot are adaptively chosen:\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\nplot_parametric(0..2pi, r₂)  # interval first\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n![](plots_plotting_files/figure-html/cell-10-output-1.svg){}\n:::\n:::\n\n\n### Plotting a space curve in 3 dimensions\n\n\nA parametrically described curve in 3D is similarly created. For example, a helix is described mathematically by $r(t) = \\langle \\sin(t), \\cos(t), t \\rangle$. Here we graph two turns:\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\nr₃(t) = [sin(t), cos(t), t]\nplot_parametric(0..4pi, r₃)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n![](plots_plotting_files/figure-html/cell-11-output-1.svg){}\n:::\n:::\n\n\n### Adding a vector\n\n\nThe tangent vector indicates the instantaneous direction one would travel were they walking along the space curve. We can add a tangent vector to the graph. The `quiver!` function would be used to add a 2D vector, but `Plots` does not currently have a `3D` analog. In addition, `quiver!` has a somewhat cumbersome calling pattern when adding just one vector. The `CalculusWithJulia` package defines an `arrow!` function that uses `quiver` for 2D arrows and a simple line for 3D arrows. As a vector incorporates magnitude and direction, but not a position, `arrow!` needs both a point for the position and a vector.\n\n\nHere is how we can visualize the tangent vector at a few points on the helix:\n\n``` {.julia .cell-code}\nplot_parametric(0..4pi, r₃, legend=false)\nts = range(0, 4pi, length=5)\nfor t in ts\n   arrow!(r₃(t), r₃'(t))\nend\n```\n\n\n::: {.cell execution_count=12}\n\n::: {.cell-output .cell-output-display execution_count=13}\n```{=html}\n<div class=\"markdown\"><div class=\"admonition info\"><p class=\"admonition-title\">Info</p><p>Adding many arrows this way would be inefficient.</p>\n</div>\n</div>\n```\n:::\n:::\n\n\n### Setting a viewing angle for 3D plots\n\n\nFor 3D plots, the viewing angle can make the difference in visualizing the key features. In `Plots`, some backends allow the viewing angle to be set with the mouse by clicking and dragging. Not all do. For such, the `camera` argument is used, as in `camera(azimuthal, elevation)` where the angles are given in degrees. If the $x$-$y$-$z$ coorinates are given, then `elevation` or *inclination*, is the angle between the $z$ axis and the $x-y$ plane (so `90` is a top view) and `azimuthal` is the angle in the $x-y$ plane from the $x$ axes.\n\n\n## Visualizing functions from $R^2 \\rightarrow R$\n\n\nIf a function $f: R^2 \\rightarrow R$ then a graph of $(x,y,f(x,y))$ can be represented in 3D. It will form a surface. Such graphs can be most simply made by specifying a set of $x$ values, a set of $y$ values and a function $f$, as with:\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\nxs = range(-2, stop=2, length=100)\nys = range(-pi, stop=pi, length=100)\nf(x,y) = x*sin(y)\nsurface(xs, ys, f)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n![](plots_plotting_files/figure-html/cell-14-output-1.svg){}\n:::\n:::\n\n\nRather than pass in a function, values can be passed in. Here they are generated with a list comprehension. The `y` values are innermost to match the graphic when passing in a function object:\n\n::: {.cell hold='true' execution_count=14}\n``` {.julia .cell-code}\nzs = [f(x,y) for y in ys, x in xs]\nsurface(xs, ys, zs)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n![](plots_plotting_files/figure-html/cell-15-output-1.svg){}\n:::\n:::\n\n\nRemembering if the `ys` or `xs` go first in the above can be hard. Alternatively, broadcasting can be used. The command `f.(xs,ys)` would return a vector, as the `xs` and `ys` match in shape–they are both column vectors. But the *transpose* of `xs` looks like a *row* vector and `ys` looks like a column vector, so broadcasting will create a matrix of values, as desired here:\n\n::: {.cell execution_count=15}\n``` {.julia .cell-code}\nsurface(xs, ys, f.(xs', ys))\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n![](plots_plotting_files/figure-html/cell-16-output-1.svg){}\n:::\n:::\n\n\nThis graph shows the tessalation algorithm. Here only the grid in the $x$-$y$ plane is just one cell:\n\n::: {.cell hold='true' execution_count=16}\n``` {.julia .cell-code}\nxs = ys = range(-1, 1, length=2)\nf(x,y) = x*y\nsurface(xs, ys, f)\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n![](plots_plotting_files/figure-html/cell-17-output-1.svg){}\n:::\n:::\n\n\nA more accurate graph, can be seen here:\n\n::: {.cell hold='true' execution_count=17}\n``` {.julia .cell-code}\nxs = ys = range(-1, 1, length=100)\nf(x,y) = x*y\nsurface(xs, ys, f)\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n![](plots_plotting_files/figure-html/cell-18-output-1.svg){}\n:::\n:::\n\n\n### Contour plots\n\n\nReturning to the\n\n\nThe contour plot of $f:R^2 \\rightarrow R$ draws level curves, $f(x,y)=c$, for different values of $c$ in the $x-y$ plane. They are produced in a similar manner as the surface plots:\n\n::: {.cell hold='true' execution_count=18}\n``` {.julia .cell-code}\nxs = ys = range(-2,2, length=100)\nf(x,y) = x*y\ncontour(xs, ys, f)\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n![](plots_plotting_files/figure-html/cell-19-output-1.svg){}\n:::\n:::\n\n\nThe cross in the middle corresponds to $c=0$, as when $x=0$ or $y=0$ then $f(x,y)=0$.\n\n\nSimilarly, computed values for $f(x,y)$ can be passed in. Here we change the function:\n\n::: {.cell hold='true' execution_count=19}\n``` {.julia .cell-code}\nf(x,y) = 2 - (x^2 + y^2)\nxs = ys = range(-2,2, length=100)\n\nzs = [f(x,y) for y in ys, x in xs]\n\ncontour(xs, ys, zs)\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n![](plots_plotting_files/figure-html/cell-20-output-1.svg){}\n:::\n:::\n\n\nThe chosen levels can be specified by the user through the `levels` argument, as in:\n\n::: {.cell hold='true' execution_count=20}\n``` {.julia .cell-code}\nf(x,y) = 2 - (x^2 + y^2)\nxs = ys = range(-2,2, length=100)\n\nzs = [f(x,y) for y in ys, x in xs]\n\ncontour(xs, ys, zs, levels = [-1.0, 0.0, 1.0])\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n![](plots_plotting_files/figure-html/cell-21-output-1.svg){}\n:::\n:::\n\n\nIf only a single level is desired, as scalar value can be specified. Though not with all backends for `Plots`. For example, this next graphic shows the $0$-level of the [devil](http://www-groups.dcs.st-and.ac.uk/~history/Curves/Devils.html)'s curve.\n\n::: {.cell hold='true' execution_count=21}\n``` {.julia .cell-code}\na, b = -1, 2\nf(x,y) = y^4 - x^4 + a*y^2 + b*x^2\nxs = ys = range(-5, stop=5, length=100)\ncontour(xs, ys, f, levels=[0.0])\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n![](plots_plotting_files/figure-html/cell-22-output-1.svg){}\n:::\n:::\n\n\nContour plots are well known from the presence of contour lines on many maps. Contour lines indicate constant elevations. A peak is characterized by a series of nested closed paths. The following graph shows this for the peak at $(x,y)=(0,0)$.\n\n::: {.cell hold='true' execution_count=22}\n``` {.julia .cell-code}\nxs = ys = range(-pi/2, stop=pi/2, length=100)\nf(x,y) = sinc(sqrt(x^2 + y^2))   # sinc(x) is sin(x)/x\ncontour(xs, ys, f)\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n![](plots_plotting_files/figure-html/cell-23-output-1.svg){}\n:::\n:::\n\n\nContour plots can be filled with colors through the `contourf` function:\n\n::: {.cell hold='true' execution_count=23}\n``` {.julia .cell-code}\nxs = ys = range(-pi/2, stop=pi/2, length=100)\nf(x,y) = sinc(sqrt(x^2 + y^2))\n\ncontourf(xs, ys, f)\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n![](plots_plotting_files/figure-html/cell-24-output-1.svg){}\n:::\n:::\n\n\n### Combining surface plots and contour plots\n\n\nIn `PyPlot` it is possible to add a contour lines to the surface, or projected onto an axis. To replicate something similar, though not as satisfying, in `Plots` we use the `Contour` package.\n\n::: {.cell hold='true' execution_count=24}\n``` {.julia .cell-code}\nf(x,y) = 2 + x^2 + y^2\nxs = ys = range(-2, stop=2, length=100)\nzs = [f(x,y) for y in ys, x in xs]\n\np = surface(xs, ys, zs, legend=false, fillalpha=0.5)\n\n## we add to the graphic p, then plot\nfor cl in levels(contours(xs, ys, zs))\n    lvl = level(cl) # the z-value of this contour level\n    for line in lines(cl)\n        _xs, _ys = coordinates(line) # coordinates of this line segment\n        _zs = 0 * _xs\n        plot!(p, _xs, _ys, lvl .+ _zs, alpha=0.5) # add on surface\n        plot!(p, _xs, _ys, _zs, alpha=0.5)        # add on x-y plane\n    end\nend\np\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n![](plots_plotting_files/figure-html/cell-25-output-1.svg){}\n:::\n:::\n\n\nThere is no hidden line calculuation, in place we give the contour lines a transparency through the argument `alpha=0.5`.\n\n\n### Gradient and surface plots\n\n\nThe surface plot of $f: R^2 \\rightarrow R$ plots $(x, y, f(x,y))$ as a surface. The *gradient* of $f$ is $\\langle \\partial f/\\partial x, \\partial f/\\partial y\\rangle$. It is a two-dimensional object indicating the direction at a point $(x,y)$ where the surface has the greatest ascent. Illurating the gradient and the surface on the same plot requires embedding the 2D gradient into the 3D surface. This can be done by adding a constant $z$ value to the gradient, such as $0$.\n\n::: {.cell hold='true' execution_count=25}\n``` {.julia .cell-code}\nf(x,y) = 2 - (x^2 + y^2)\nxs = ys = range(-2, stop=2, length=100)\nzs = [f(x,y) for y in ys, x in xs]\n\nsurface(xs, ys, zs, camera=(40, 25), legend=false)\np = [-1, 1] # in the region graphed, [-2,2] × [-2, 2]\n\nf(x) = f(x...)\nv = ForwardDiff.gradient(f, p)\n\n\n# add 0 to p and v (two styles)\npush!(p, -15)\nscatter!(unzip([p])..., markersize=3)\n\nv = vcat(v, 0)\narrow!(p, v)\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n![](plots_plotting_files/figure-html/cell-26-output-1.svg){}\n:::\n:::\n\n\n### The tangent plane\n\n\nLet $z = f(x,y)$ describe a surface, and $F(x,y,z) = f(x,y) - z$. The the gradient of $F$ at a point $p$ on the surface, $\\nabla F(p)$, will be normal to the surface and for a function, $f(p) + \\nabla f \\cdot (x-p)$ describes the tangent plane. We can visualize each, as follows:\n\n::: {.cell hold='true' execution_count=26}\n``` {.julia .cell-code}\nf(x,y) = 2 - x^2 - y^2\nf(v) = f(v...)\nF(x,y,z) = z - f(x,y)\nF(v) = F(v...)\np = [1/10, -1/10]\nglobal p1 = vcat(p, f(p...)) # note F(p1) == 0\nglobal n⃗ = ForwardDiff.gradient(F, p1)\nglobal tl(x) = f(p) +  ForwardDiff.gradient(f, p) ⋅ (x - p)\ntl(x,y) = tl([x,y])\n\nxs = ys = range(-2, stop=2, length=100)\nsurface(xs, ys, f)\nsurface!(xs, ys, tl)\narrow!(p1, 5n⃗)\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n![](plots_plotting_files/figure-html/cell-27-output-1.svg){}\n:::\n:::\n\n\nFrom some viewing angles, the normal does not look perpendicular to the tangent plane. This is a quick verification for a randomly chosen point in the $x-y$ plane:\n\n::: {.cell execution_count=27}\n``` {.julia .cell-code}\na, b = randn(2)\ndot(n⃗, (p1 - [a,b, tl(a,b)]))\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\n-5.551115123125783e-17\n```\n:::\n:::\n\n\n### Parameterized surface plots\n\n\nAs illustrated, we can plot surfaces of the form $(x,y,f(x,y)$. However, not all surfaces are so readily described. For example, if $F(x,y,z)$ is a function from $R^3 \\rightarrow R$, then $F(x,y,z)=c$ is a surface of interest. For example, the sphere of radius one is a solution to $F(x,y,z)=1$ where $F(x,y,z) =  x^2 + y^2 + z^2$.\n\n\nPlotting such generally described surfaces is not so easy, but *parameterized* surfaces can be represented. For example, the sphere as a surface is not represented as a surface of a function, but can be represented in spherical coordinates as parameterized by two angles, essentially an \"azimuth\" and and \"elevation\", as used with the `camera` argument.\n\n\nHere we define functions that represent $(x,y,z)$ coordinates in terms of the corresponding spherical coordinates $(r, \\theta, \\phi)$.\n\n::: {.cell execution_count=28}\n``` {.julia .cell-code}\n# spherical: (radius r, inclination θ, azimuth φ)\nX(r,theta,phi) = r * sin(theta) * sin(phi)\nY(r,theta,phi) = r * sin(theta) * cos(phi)\nZ(r,theta,phi) = r * cos(theta)\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\nZ (generic function with 1 method)\n```\n:::\n:::\n\n\nWe can parameterize the sphere by plotting values for $x$, $y$, and $z$ produced by a sequence of values for $\\theta$ and $\\phi$, holding $r=1$:\n\n::: {.cell hold='true' execution_count=29}\n``` {.julia .cell-code}\nthetas = range(0, stop=pi,   length=50)\nphis   = range(0, stop=pi/2, length=50)\n\nxs = [X(1, theta, phi) for theta in thetas, phi in phis]\nys = [Y(1, theta, phi) for theta in thetas, phi in phis]\nzs = [Z(1, theta, phi) for theta in thetas, phi in phis]\n\nsurface(xs, ys, zs)\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n![](plots_plotting_files/figure-html/cell-30-output-1.svg){}\n:::\n:::\n\n\n::: {.cell execution_count=30}\n\n::: {.cell-output .cell-output-display execution_count=31}\n```{=html}\n<div class=\"markdown\"><div class=\"admonition info\"><p class=\"admonition-title\">Info</p><p>The above may not work with all backends for <code>Plots</code>, even if those that support 3D graphics.</p>\n</div>\n</div>\n```\n:::\n:::\n\n\nFor convenience, the `plot_parametric` function from `CalculusWithJulia` can produce these plots using interval notation, `a..b`,  and a function:\n\n::: {.cell hold='true' execution_count=31}\n``` {.julia .cell-code}\nF(theta, phi) = [X(1, theta, phi), Y(1, theta, phi), Z(1, theta, phi)]\nplot_parametric(0..pi, 0..pi/2, F)\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n![](plots_plotting_files/figure-html/cell-32-output-1.svg){}\n:::\n:::\n\n\n### Plotting  F(x,y, z) = c\n\n\nThere is no built in functionality in `Plots` to create surface described by $F(x,y,z) = c$. An example of how to provide some such functionality for `PyPlot` appears [here](https://stackoverflow.com/questions/4680525/plotting-implicit-equations-in-3d ). The non-exported `plot_implicit_surface` function can be used to approximate this.\n\n\nTo use it, we see what happens when a sphere if rendered:\n\n::: {.cell hold='true' execution_count=32}\n``` {.julia .cell-code}\nf(x,y,z) = x^2 + y^2 + z^2 - 25\nCalculusWithJulia.plot_implicit_surface(f)\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n![](plots_plotting_files/figure-html/cell-33-output-1.svg){}\n:::\n:::\n\n\nThis figure comes from a February 14, 2019 article in the [New York Times](https://www.nytimes.com/2019/02/14/science/math-algorithm-valentine.html). It shows an equation for a \"heart,\" as the graphic will illustrate:\n\n::: {.cell hold='true' execution_count=33}\n``` {.julia .cell-code}\na,b = 1,3\nf(x,y,z) = (x^2+((1+b)*y)^2+z^2-1)^3-x^2*z^3-a*y^2*z^3\nCalculusWithJulia.plot_implicit_surface(f, xlim=-2..2, ylim=-1..1, zlim=-1..2)\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n![](plots_plotting_files/figure-html/cell-34-output-1.svg){}\n:::\n:::\n\n\n",
    "supporting": [
      "plots_plotting_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}